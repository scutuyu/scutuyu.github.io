<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[awesome dispatcher servlet]]></title>
    <url>%2F2019%2F02%2F16%2Fawesome-dispatcher-servlet%2F</url>
    <content type="text"><![CDATA[概述web应用一般都运行于web容器中，比如Tomcat服务器，Spring MVC框架定义了一个Servlet叫DispatcherServlet，传统的做法就是在web.xml配置文件中将该Servlet配置到Servlet容器中，并拦截所有的请求/或者/*。 我自定义了一个Servlet，拦截所有的请求，它继承HttpServlet，重写了父类GenericServlet的init()，做一些初始化的工作；重写了HttpServlet的service()，完成请求的分发，功能类似Spring MVC的DispatcherServlet，但是没有它那么强大。项目地址在这里。 初始化并缓存所有处理器 拦截所有请求 静态资源特殊处理 请求分发 初始化并缓存所有处理器通过Servlet的init()初始化项目中所有的控制器类，并把它们缓存在一个Map中，key是URI，value是封装了处理该URI的处理器类、方法等信息。 拦截所有请求在自定义的DispatcherServlet类上使用Servlet 3.0的@WebServlet注解，并指定urlPatterns属性，值为/或者/*，多说一句，查阅资料发现，/和/*其实表示的意思是一样的，都表示任意的URL，Servlet的urlPattern不是简单的通配符，也不是正则表达式，而是具有自己的匹配规则。 静态资源特殊处理判断请求是否为静态资源，项目中直接判断URI是否为/，如果是，将返回根目录下的index.html文件 请求分发根据请求的URI，在处理器缓存中查找对应的处理器，如果找不到，则返回404，如果找到了，就利用反射机制，让处理器类的实例来处理请求，最后将结果使用fastjson做序列化并响应请求。 参考链接]]></content>
  </entry>
  <entry>
    <title><![CDATA[personal understanding of red-black tree]]></title>
    <url>%2F2019%2F01%2F23%2Fpersonal-understanding-of-red-black-tree%2F</url>
    <content type="text"><![CDATA[概述红黑树的定义： 根节点为黑色 所有节点非黑即红 红色节点的子节点必须是黑色 从根节点到它所有子节点的路径中包含相同数量的黑色节点 CLR 变色 左旋 右旋 红黑树的自平衡 CLRCLR是三个人名的缩写，分别是Cormen、Leiserson和Rivest，他们都是第一版《算法导论》的作者. 在jdk8源码中，TreeMap类中关于fixAfterInsertion方法的实现就是从《算法导论》中获取的，由方法上的注释可知：1234/** From CLR */private void fixAfterInsertion(Entry&lt;K,V&gt; x) &#123; ...&#125; 变色在fixAfterInsertion方法中，第二步就是判断叔叔节点的颜色，如果叔叔节点是红色，就将父亲节点和x节点(x节点就是当前插入的节点)颜色变为黑色，祖父节点变为红色，并将x指向祖父节点进行递归调用 左旋在fixAfterInsertion方法中，有两个地方可能会左旋，父亲节点是祖父节点的右节点，且自己是父节点的右节点，父节点变为黑色，祖父节点变为红色，对祖父节点进行左旋；第二个地方是，如果父节点是祖父节点的左节点，且自己是父节点的右节点，此时会先对父节点进行左旋 右旋和左旋类似，在fixAfterInsertion方法中，有两个地方可能会右旋，父节点是是祖父节点的左节点，且自己是父节点的左节点，父节点变为黑色，祖父节点变为红色，对父节点进行右旋；第二给地方是，如果父节点是祖父节点的右节点，且自己是父节点的左节点，此时会先对父节点进行右旋 红黑树的自平衡红黑树的自平衡在TreeMap中体现在两个地方，一个是fixAfterInsertion,一个是fixAfterDeletion。 在fixAfterInsertion方法中，自平衡的逻辑在一个while循环中，终止条件是传入的节点（比如x节点）不等于null，且不是根节点，且颜色等于红色；如果x节点的父节点是祖父节点的左节点，如果叔叔节点是红色，则执行变色逻辑，反之，则执行右旋逻辑，在执行右旋之前，如果x节点是父节点的右节点，要先对父节点执行左旋（不变色），最后再执行右旋；如果x节点的父节点是祖父节点的右节点，如果叔叔节点是红色，则执行变色逻辑，反之，则执行左旋逻辑，在执行左旋之前，如果x节点是父节点的左节点，要先对父节点执行右旋（不变色），最后在执行左旋。 在fixAfterDeletion方法中，自平衡的逻辑也在一个while循环中，终止条件是传入的节点（比如x节点）不等于null，未完待续… 参考链接]]></content>
      <tags>
        <tag>红黑树</tag>
        <tag>变色</tag>
        <tag>左旋</tag>
        <tag>右旋</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring mvc 自定义参数绑定，自定义数据返回格式]]></title>
    <url>%2F2018%2F12%2F18%2Fspring-mvc-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A%EF%BC%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E8%BF%94%E5%9B%9E%E6%A0%BC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[概述工作中有这么个需求：前端请求后端数据时参数采用蛇形命名法,即：/xxxx?user_name=ty&amp;user_age=12，后端返回的json数据要也要蛇形命名法，即：12345678&#123; "user_name": "tuyu", "user_age": 12, "address": "xxxxx"&#125;需要做两件事：1. controller的方法的参数的命名方式采用小驼峰命名，希望将前端传递的蛇形命名的参数自动绑定到对应的驼峰命名的参数上2. 后端返回的json数据的命名方式采用蛇形命名法 参数绑定配置参数解析器新建一个配置类继承WebMvcConfigurationSupport类，并加上@Configuration注解，重写addArgumentResolvers方法，需要在参数解析器列表中添加一个自定义的参数解析器，该自定义的参数解析器需要实现HandlerMethodArgumentResolver接口，并实现supportsParameter方法和resolveArgument方法。 配置HttpMessageConverter要想返回返回的json数据采用蛇形命名法，在spring boot项目中有两种方法： 在主配置文件application.properties文件中添加配置项spring.jackson.property-naming-strategy=CAMEL_CASE_TO_LOWER_CASE_WITH_UNDERSCORES 新建一个配置类继承WebMvcConfigurationSupport类，并加上@Configuration注解，重写configureMessageConverters方法，方法中实例化一个MappingJackson2HttpMessageConverter对象加入到HttpMessageConverter列表中，并为其设置一个PropertyNamingStrategy为PropertyNamingStrategy.SnakeCaseStrategy()的ObjectMapper，此外为MappingJackson2HttpMessageConverter对象设置supportedMediaTypes属性为MediaType.APPLICATION_JSON_UTF8，即：12345MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();ObjectMapper mapper = new ObjectMapper();mapper.setPropertyNamingStrategy(PropertyNamingStrategy.SnakeCaseStrategy());converter.setObjectMapper(mapper);converter.setSupportedMediaTypes(Arrays.asList(MedidaType.APPLICATION_JSON_UTF8)); 整个配置文件如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399@Configurationpublic class WebAppConfig extends CorsConfig &#123; @Autowired private Validator validator; @Override protected void addInterceptors(InterceptorRegistry registry) &#123; super.addInterceptors(registry); &#125; /** * 配置参数绑定解析器 * @param argumentResolvers */ @Override protected void addArgumentResolvers(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers) &#123; System.out.println("hello word , resolver"); argumentResolvers.add(new UnderlineToCamelArgumentResolver(validator)); &#125; /** * 配置converter * @param converters */ @Override protected void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;// jacksonConverter(converters); fastJsonConverter(converters); &#125; private void jacksonConverter(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123; MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter()&#123; @Override protected void writeInternal(Object object, Type type, HttpOutputMessage outputMessage) throws IOException, HttpMessageNotWritableException &#123; if (object instanceof ReturnData) &#123; object = getUnderscoreMap(object); &#125; super.writeInternal(object, type, outputMessage); &#125; &#125;; converter.setObjectMapper(new ObjectMapper().setPropertyNamingStrategy(new PropertyNamingStrategy.LowerCaseStrategy())); converter.setSupportedMediaTypes(Arrays.asList(MediaType.APPLICATION_JSON_UTF8)); converters.add(converter); &#125; private void fastJsonConverter(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123; FastJsonHttpMessageConverter converter = new FastJsonHttpMessageConverter()&#123; @Override protected void writeInternal(Object object, HttpOutputMessage outputMessage) throws IOException, HttpMessageNotWritableException &#123; if (object instanceof ReturnData) &#123; object = getUnderscoreMap(object); &#125; else if (object instanceof Json) &#123; object = handleSwaggerWebJson(object); &#125; super.writeInternal(object, outputMessage); &#125; &#125;; SerializeConfig serializeConfig = new SerializeConfig(); serializeConfig.setPropertyNamingStrategy(com.alibaba.fastjson.PropertyNamingStrategy.CamelCase); FastJsonConfig fastJsonConfig = new FastJsonConfig(); fastJsonConfig.setSerializeConfig(serializeConfig); converter.setFastJsonConfig(fastJsonConfig); converters.add(converter); &#125; /** * 将swagger请求的json数据特殊处理 * &lt;p&gt;将系统中查询的驼峰命名的数据转为蛇形命名法&lt;/p&gt; * @param object * * @return */ private static Object handleSwaggerWebJson(Object object) &#123; Json json = (Json) object; String jsonStr = json.value(); jsonStr = SwaggerJsonHelper.preHandle(jsonStr); LinkedHashMap resultMap = JSON.parseObject(jsonStr, LinkedHashMap.class); // 找所有paths Map paths = (Map) resultMap.get("paths"); if (paths != null) &#123; for (Object path : paths.entrySet()) &#123; // 每个path都会是post或者get或者put或者delete请求 Map.Entry pathEntry = (Map.Entry) path; Map methods = (Map) pathEntry.getValue(); for (Object method : methods.entrySet()) &#123; Map.Entry methodEntry = (Map.Entry) method; Map methodMap = (Map) methodEntry.getValue(); for (Object param : methodMap.entrySet()) &#123; JSONArray paramArray = (JSONArray) methodMap.get("parameters"); for (Object pa : paramArray) &#123; Map paramMap = (Map) pa; Object name = paramMap.get("name"); if (name != null) &#123; String underscore = humpToLine(name.toString()); paramMap.put("name", underscore); &#125; &#125; &#125; &#125; &#125; &#125; Map definitions = (Map) resultMap.get("definitions"); if (definitions != null) &#123; for (Object po : definitions.keySet()) &#123; Map poMap = (Map) definitions.get(po); JSONArray requiredArr = (JSONArray) poMap.get("required"); if (requiredArr != null) &#123; int arrSize = requiredArr.size(); for (int i = 0; i &lt; arrSize; i++) &#123; Object key = null; if ((key = requiredArr.get(i)) != null) &#123; requiredArr.set(i, humpToLine(key.toString())); &#125; &#125; &#125; Map propertyMap = (Map) poMap.get("properties"); if (propertyMap != null) &#123; Map newPropertyMap = new HashMap(propertyMap.size()); for (Object key : propertyMap.keySet()) &#123; newPropertyMap.put(humpToLine(key.toString()), propertyMap.get(key)); &#125; poMap.put("properties", newPropertyMap); &#125; &#125; &#125; String result = JSON.toJSONString(resultMap); result = SwaggerJsonHelper.postHandle(result); return new Json(result); &#125; private static class SwaggerJsonHelper &#123; private static final String DOLLAR = "MEIYUANFUHAO"; private static final String JING = "JINZIFU"; /** * 将字符串中的特殊字符$、#替换为特殊的字符组合 * @param jsonStr * * @return */ public static String preHandle(String jsonStr) &#123; return jsonStr.replaceAll("\\$", DOLLAR).replaceAll("\\#", JING); &#125; /** * 将字符串中的特殊的字符组合替换为特殊字符$、# * @param jsonStr * * @return */ public static String postHandle(String jsonStr) &#123; return jsonStr.replaceAll(DOLLAR, "\\$").replaceAll(JING, "\\#"); &#125; &#125; /** * 下划线转驼峰参数绑定解析器 */ private static class UnderlineToCamelArgumentResolver implements HandlerMethodArgumentResolver &#123; private Validator validator; public UnderlineToCamelArgumentResolver() &#123; &#125; public UnderlineToCamelArgumentResolver(Validator validator) &#123; this.validator = validator; &#125; /** * 匹配下划线的格式 */ private static Pattern pattern = Pattern.compile("_(\\w)"); private static String underLineToCamel(String source) &#123; Matcher matcher = pattern.matcher(source); StringBuffer sb = new StringBuffer(); while (matcher.find()) &#123; matcher.appendReplacement(sb, matcher.group(1).toUpperCase()); &#125; matcher.appendTail(sb); return sb.toString(); &#125; @Override public boolean supportsParameter(MethodParameter methodParameter) &#123; return true; &#125; @Override public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer container, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) &#123; return handleParameterNames(parameter, webRequest); &#125; private Object handleParameterNames(MethodParameter parameter, NativeWebRequest webRequest) &#123; if (isSimpleType(parameter.getParameterType())) &#123; // 基本类型 String parameterName = parameter.getParameterName(); String snake = humpToLine(parameterName); String real = webRequest.getParameter(snake); if (real == null) &#123; real = webRequest.getParameter(parameterName); &#125; return real == null ? null : getObject(parameter.getParameterType(), real); &#125; else &#123; // 自定义类型 Object obj = BeanUtils.instantiate(parameter.getParameterType()); BeanWrapper wrapper = PropertyAccessorFactory.forBeanPropertyAccess(obj); Iterator&lt;String&gt; paramNames = webRequest.getParameterNames(); while (paramNames.hasNext()) &#123; String paramName = paramNames.next(); Object o = webRequest.getParameter(paramName); try &#123; wrapper.setPropertyValue(underLineToCamel(paramName), o); &#125; catch (BeansException e) &#123; &#125; &#125; // 参数校验 if (parameter.hasParameterAnnotation(Valid.class)) &#123; Set&lt;ConstraintViolation&lt;Object&gt;&gt; validate = validator.validate(obj); if (validate != null &amp;&amp; validate.size() != 0) &#123; StringBuilder sb = new StringBuilder(); int size = validate.size(); int i = 0; for (ConstraintViolation&lt;Object&gt; cv : validate) &#123; sb.append(cv.getMessage()); i++; if (i &lt; size) &#123; sb.append(", "); &#125; &#125; // 校验不通过，直接报异常 throw new RuntimeException(sb.toString()); &#125; &#125; return obj; &#125; &#125; &#125; /** * 利用反射实例化一个对象 * @param clazz 对象类型 * @param value 值 * * @return */ private static Object getObject(Class clazz, String value) &#123; Constructor constructor = null; Object o1 = null; try &#123; constructor = clazz.getConstructor(String.class); o1 = constructor.newInstance(value); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; return o1; &#125; /** * 判断是否为基本数据类型、简单类型 * @param clazz * * @return */ private static boolean isSimpleType(Class&lt;?&gt; clazz) &#123; String simpleName = clazz.getSimpleName(); boolean simple = false; switch (simpleName.toLowerCase()) &#123; case "byte": simple = true; break; case "short": simple = true; break; case "int": simple = true; break; case "integer": simple = true; break; case "long": simple = true; break; case "float": simple = true; break; case "double": simple = true; break; case "boolean": simple = true; break; case "char": simple = true; break; case "character": simple = true; break; case "bigdecimal": simple = true; break; case "string": simple = true; break; default: simple = false; break; &#125; return simple; &#125; /** * 下划线转驼峰 * * @param str * * @return */ public static String lineToHump(String str) &#123; str = str.toLowerCase(); Matcher matcher = linePattern.matcher(str); StringBuffer sb = new StringBuffer(); while (matcher.find()) &#123; matcher.appendReplacement(sb, matcher.group(1).toUpperCase()); &#125; matcher.appendTail(sb); return sb.toString(); &#125; private static Pattern linePattern = Pattern.compile("_([a-z])"); private static Pattern humpPattern = Pattern.compile("[A-Z]"); /** * 驼峰转下划线 * * @param str * * @return */ public static String humpToLine(String str) &#123; Matcher matcher = humpPattern.matcher(str); StringBuffer sb = new StringBuffer(); while (matcher.find()) &#123; matcher.appendReplacement(sb, "_" + matcher.group(0).toLowerCase()); &#125; matcher.appendTail(sb); return sb.toString(); &#125; /** * 反射对象字段 * * @param obj * * @return */ public static Map&lt;String, Object&gt; getUnderscoreMap(Object obj) &#123; if (obj == null) &#123; return null; &#125; Class&lt;?&gt; bindClass = obj.getClass(); Map&lt;String, Object&gt; objMap = new HashMap&lt;&gt;(0); /* * 得到类中的所有属性集合 */ try &#123; Field[] fs = bindClass.getDeclaredFields(); for (Field f : fs) &#123; //设置些属性是可以访问的 f.setAccessible(true); if (!isSimpleType(f.getType())) &#123; Map&lt;String, Object&gt; childMap = getUnderscoreMap(f.get(obj)); objMap.put(humpToLine(f.getName()), childMap); &#125; else &#123; objMap.put(humpToLine(f.getName()), f.get(obj)); &#125; &#125; &#125; catch (IllegalAccessException e) &#123; System.out.println(e.getMessage()); &#125; objMap.remove("serial_version_u_i_d"); return objMap; &#125;&#125; 配置文件有点长，因为除了解决上面提到的两个问题之外，还解决了其他问题： 项目中使用了swagger自动生成接口文档，swagger请求的json数据需要驼峰命名，但是项目返回的是蛇形名的数据，swagger报错 项目中使用JSR-303，JSR-349做参数校验，在没有自定义参数解析器的时候，验证是生效的，自定义参数解析器后，参数验证不生效了 解决swagger需要驼峰命名的json数据问题在查阅资料后得知，所有实现HttpMessageConverter接口的子类，真正将json数据写到response的方法是writeInteral,MappingJackson2HttpMessageConverter也不例外，那么我就重写它的writeInteral方法，如果要写入的对象是swagger查询的对象类型，我就特殊对待，如果对象是controller中方法返回的统一封装的对象，就将该对象所有属性都变为蛇形命名，并将其放在Map中，再调父类的writeInteral方法处理，其他的对象就直接调用父类的writeInteral方法即可，那么MappingJackson2HttpMessageConverter对象也没有必要把ObjectMapper的PropertyNamingStrategy设为PropertyNamingStrategy.SnakeCaseStrategy()了，因为需要转换的对象已被转为蛇形命名的Map了。 解决自定义参数解析器之后参数验证不生效问题在查阅资料后得知，可以手动调用Validator对参数进行校验，于是我可以在参数绑定完成之后，判断参数是否有注解@Valid来决定是手动进行参数验证，如果验证失败，就抛出运行时异常，有全局异常处理器处理，如果验证通过就返回。 其实在这一系列过程中，我还遇到了另外的问题： 同一个spring mvc项目中如果有多个继承WebMvcConfigurationSupport类的配置类，spring mvc框架只会让第一个被扫描的配置类生效，如果确实有多个配置类存在的必要，比如该项目：依赖了一个jar包，它里面用拦截器配置了一些统一认证的逻辑，而项目要配置自定义参数解析器等配置，这就会出现两个配置类，而依赖的jar包中的配置类我修改不了，能改的只有本项目的配置类。 解决方法：既然只能修改本项目的配置类，那么就可以让本项目的配置类（B）继承依赖jar包的配置类(A)，并在spring boot的启动类上加上注解排除依赖类的配置类（A）,即：1234@SpringBootApplication(exclude=A.class)public class WebApplication&#123; // ....&#125; swagger返回的json数据有这么一段:123&#123; "$ref": "#/definitions/xxxxx"&#125; 当我用fastjson转为Map时，由于$和#是特殊字符，转换发生了错误 解决办法是：在转换前将特殊字符替换为特定的字符串，最后又将特定的字符串替换为特殊字符，eg:jsonStr.replaceAll(&quot;\\$&quot;, &quot;DOLLAR&quot;).replaceAll(&quot;\\#&quot;, &quot;JING&quot;) 参考链接 spring validator手动校验 Jackson 在 Spring Boot 中的使用小结 1 Java Json 数据下划线与驼峰格式进行相互转换 SpringMVC对象绑定时自定义名称对应关系 SpringBoot 自定义方法参数解析器HandlerMethodArgumentResolver]]></content>
      <categories>
        <category>spring mvc</category>
      </categories>
      <tags>
        <tag>spring mvc</tag>
        <tag>蛇形命名</tag>
        <tag>驼峰命名</tag>
        <tag>HandleMethodArgumentResolver</tag>
        <tag>HttpMessageConverter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反编译jar包]]></title>
    <url>%2F2018%2F09%2F14%2F%E5%8F%8D%E7%BC%96%E8%AF%91jar%E5%8C%85%2F</url>
    <content type="text"><![CDATA[概述 unzip解压jar包 jad反编译class文件 自定义反编译工具-编写shell文件 jar包的解压有两种方式，使用jar命令或者unzip命令由于jar命令不能将输出重定向到指定的文件夹，故选择unzip命令使用jar来解压的命令只能将解压后的数据解压到当前文件夹12345jar -xvf dcm-stats-service-impl.jar# 1. -x 解压# 2. -v 打印解压过程# 3. -f jar包名 12345unzip -qo dcm-stats-service-impl.jar -d classes# 1. -q 安静执行，不打印输出# 2. -o 覆盖文件# 3. -d 指定输出文件目录 jad反编译对多个java字节码文件进行反编译1234567jad -o -r -sjava -dsrc &apos;classes/com/**/*.class&apos; &gt; /dev/null 2&gt;&amp;1# 1. -o 覆盖文件# 2. -r 保存包目录的结构# 3. -s 指定输出文件的后缀名# 4. -d 指定输出文件目录# 5. &gt; /dev/null 2&gt;&amp;1 将输出信息（标准输出，标准错误）都输出到/dev/null(空设备文件),即不显示输出信息 自定义反编译工具-编写shell文件文件名为decompile 12345678910111213141516171819202122232425262728293031#! /bin/bash# 获取需要反编译的jar包名JAR_NAME=$&#123;1&#125;# 判断输入的jar包名是否为空if [ -n "$JAR_NAME" ]; then BASE_PATH=`pwd` JAR=$&#123;BASE_PATH&#125;/$&#123;JAR_NAME&#125; CLASSES=$&#123;BASE_PATH&#125;/classes SRC=$&#123;BASE_PATH&#125;/srcelse # 如果jar包名为空，则打印提示错误，并退出 echo "ERROR: input the file.jar" exit 2fiecho "1. unzip "$&#123;JAR_NAME&#125;" to classes"# 解压`unzip -qo $&#123;JAR&#125; -d $&#123;CLASSES&#125;`echo '2. jad all classes'# 反编译`jad -o -r -sjava -d$&#123;SRC&#125; 'classes/com/**/*.class' &gt; /dev/null 2&gt;&amp;1`echo '3. delete all classes'# 删除解压生成的临时文件夹rm -rf $&#123;CLASSES&#125;echo 'decompile successful' 为decompile添加执行权限chmod u+x decompile将decompile复制到系统环境变量能访问的地方eg:/usr/local/bin/, cp decompile /usr/local/bin/ 使用使用type命令查看decomile12➜ jar type decompiledecompile is /usr/local/bin/decompile 使用decompile命令将jar包反编译到当前目录下的src文件夹中12345678➜ too decompile ../dcm-stats-service-impl.jar1. unzip ../dcm-stats-service-impl.jar to classes2. jad all classes3. delete all classesdecompile successful➜ too lltotal 0drwxr-xr-x 3 tuyu staff 102 Sep 14 11:47 src 参考链接Linux Shell 1&gt;/dev/null 2&gt;&amp;1 含义JAD参数bash shell 获取当前正在执行脚本的绝对路径我使用过的Linux命令之exit - 退出当前shellJava - 解压和打包Jar将.jar文件解压到指定目录？使用jad反编译整个jar包]]></content>
  </entry>
  <entry>
    <title><![CDATA[三次握手]]></title>
    <url>%2F2018%2F09%2F04%2F%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%2F</url>
    <content type="text"><![CDATA[概述 TCP连接的三次握手过程 为什么要三次握手 TCP取消连接的四次挥手 为什么要四次挥手 三次握手过程 客服端向服务器发送SYN数据包 服务器向客户端发送SYN/ACK数据包 客服端向服务器发送ACK数据包 为什么要三次握手双方确认自己与对方能收发数据 第一次握手，服务端确认了自己能收数据，客服端能发数据；客服端确认了自己能发数据。 第二次握手，服务端确认了自己能收、发数据，客服端能发数据；客服端确认了自己能收、发数据，服务端能收、发数据 第三层握手，服务端确认了自己能收、发数据，客服端能收、发数据，客服端确认了自己能收、发数据，服务端能收、发数据 四次挥手过程 主动关闭方向被动关闭方发送FIN数据包 被关闭方向主动关闭方发送ACK数据包 被动关闭方关闭连接，并向主动关闭方发送FIN数据包 主动关闭方向被动关闭方发送ACK数据包 为什么药四次挥手主动关闭方提出关闭连接后，被动关闭方收到FIN并确认后，TCP连接进入半关闭状态，被动关闭方可能还有数据没有传完，需等待被动关闭方发起FIN数据包后，并收到主动关闭方的确认后，TCP连接才算完全关闭 参考链接https://github.com/Snailclimb/Java-Guide/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md]]></content>
  </entry>
  <entry>
    <title><![CDATA[Lock]]></title>
    <url>%2F2018%2F07%2F30%2FLock%2F</url>
    <content type="text"><![CDATA[概述 当调用Lock的lock方法和unlock方法时，其中发生了什么 当多个线程调用同一个Lock实例的lock方法和unlock方法时，其中又发生了什么 什么是重入锁 重入锁当前持有该锁的线程可以多次获取该锁，无需等待 参考链接]]></content>
  </entry>
  <entry>
    <title><![CDATA[queue]]></title>
    <url>%2F2018%2F07%2F26%2Fqueue%2F</url>
    <content type="text"><![CDATA[概述 Queue定义了哪些方法，是否允许添加null Deque定义了哪些方法，是否允许添加null BlockingQueue定义了哪些方法，是否允许添加null queue定义了以下方法：Queue继承Collection，Queue定义了一个线性的集合，FIFO，从一端添加元素，另一端访问元素，Queue不允许添加null，但是有个例外LinkedList它允许添加null，因为null作为特殊返回值来判断Queue是否为空覆盖父类add方法，Queue满了抛异常新增offer方法，Queue满了返回false 覆盖父类remove方法，Queue空时抛异常新增poll方法，Queue空时返回null 新增element方法，获取失败抛异常新增peak方法，获取失败返回null Deque定义了哪些方法，是否允许添加nullDeque继承Queue，是Doule end Queue的缩写，可以从队列的两端添加、删除元素，既可以像Queue一样FIFO，也可以像Stack一样LIFO，Deque对是否能插入null这件事不做强制要求，所以LinkedList就允许添加null 覆盖了add方法，Queue满了抛异常新增addFirst方法，Queue满了抛异常新增addLast方法，Queue满了抛异常 覆盖了offer方法，Queue满了返回false新增offerFirst方法，Queue满了返回false新增offerLast方法，Queue满了返回false 覆盖了remove方法，Queue空时抛异常新增removeFirst方法，Queue空时抛异常新增removeLast方法，Queue空时抛异常 覆盖了poll方法，Queue空时返回null新增pollFirst方法，Queue空时返回null新增pollLast方法，Queue空时返回null 覆盖了element方法，Queue空时抛异常新增getFirst方法，Queue空时抛异常新增getLast方法，Queue空时抛异常 覆盖了peek方法，Queue空时返回null新增peekFirst方法，Queue空时返回null新增peekLast方法，Queue空时返回null 新增pop方法，Queue空时抛异常新增push方法，Queue满了抛异常 BlockingQueue定义了以下方法：BlockingQueue继承Queue，阻塞队列在获取元素时如果队列为空，就等待队列非空，在添加元素时如果队列已满，就等待队列有剩余空间，BlockingQueue的大多数添加删除方法都是线程安全的，除了addAll, retainAll, containsAll, removeAll之外，不允许添加null元素 覆盖了add方法，Queue满了抛异常覆盖了offer方法，Queue满了返回false新增put方法，Queue满了就阻塞重载了offer方法，Queue满了就阻塞指定时间 新增take方法，Queue空时就阻塞重载了poll方法，Queue空时就阻塞指定时间 参考链接]]></content>
  </entry>
  <entry>
    <title><![CDATA[Redis集群搭过程]]></title>
    <url>%2F2018%2F07%2F23%2FRedis%E9%9B%86%E7%BE%A4%E6%90%AD%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[概述你会知道如何安装redis, ruby, rubygems如何解决gem安装依赖慢甚至失败的问题如何用gem安装redis Reids集群搭建过程 cat /etc/*-releaseCentOS Linux release 7.3.1611 (Core) wget http://download.redis.io/releases/redis-3.2.9.tar.gz下载redis的源码包 tar -xzvf redis-3.2.9.tar.gz解压源码包 cd redis-3.2.9 &amp;&amp; make &amp;&amp; make install编译，然后安装 redis-server -vRedis server v=3.2.9 sha=00000000:0 malloc=jemalloc-4.0.3 bits=64 build=5eeb62d2aadbc6d5 yum install -y ruby rubygems安装ruby,gem gem sources --add https://gems.ruby-china.org/ --remove https://rubygems.org/修改RubyGems 镜像 gem update --system升级gem gem install reids安装gem-redis依赖 vim start.sh启动脚本,内容如下： 12345678##! /bin/bashredis-server ./7000/redis.confredis-server ./7001/redis.confredis-server ./7002/redis.confredis-server ./7003/redis.confredis-server ./7004/redis.confredis-server ./7005/redis.conf vim ./700x/redis.conf修改reids配置文件，修改的内容如下： 12345678910111213141516171819202122# 端口port 7000# 后台运行daemonize yes# pid文件路径pidfile /var/run/redis_7000.pid# log文件路径logfile "nodes-7000.log"# dbfilenamedbfilename dump-7000.rdb# db文件路径dir /usr/local/share/applications/redis/dbs# 开启AOFappendonly yes# 配置AOF文件名appendfilename "appendonly-7000.aof"# 开启集群模式cluster-enabled yes# 集群配置文件cluster-config-file nodes-7000.conf# 集群间节点通信超时cluster-node-timeout 5000 chmod +x start.sh使shell脚本可以运行 ./start.sh运行start.sh脚本，启动redis实例 ps -ef | grep redis | grep -v grep查看redis实例运行情况 cp ./redis-3.2.9/src/redis-trib.rb /usr/local/bin/将redis-trib.rb复制到PATH路径上，可以在终端任何位置都可以执行redis-trib命令 vim cluster.sh集群创建脚本，内容如下： 123#! /bin/bashredis-trib create --replicas 1 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 chmod +x cluster.sh使shell脚本可以运行 ./cluster.sh运行cluster.sh脚本，创建redis集群 redis-trib check 127.0.0.1:7000查看集群状态,1234567891011121314151617181920212223&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:7000)M: 0cd3b76dee6ccc78cfe37421386a55c752ef60a5 127.0.0.1:7000 slots:0-5460 (5461 slots) master 1 additional replica(s)S: 83e2fefef3c4ed18be37f406d8b28ec3ac6ad14f 127.0.0.1:7004 slots: (0 slots) slave replicates 85903c099043fd29bb70d1b7212358d7e1317e06S: d7191c35b23f9ab381e1a26443ef19c0ccf4fed7 127.0.0.1:7003 slots: (0 slots) slave replicates 0cd3b76dee6ccc78cfe37421386a55c752ef60a5M: e9df2796f7aaf6ccb8f1c0737b9a23cd0d1ccddf 127.0.0.1:7002 slots:10923-16383 (5461 slots) master 1 additional replica(s)M: 85903c099043fd29bb70d1b7212358d7e1317e06 127.0.0.1:7001 slots:5461-10922 (5462 slots) master 1 additional replica(s)S: c134c73ec11db000bce895df5c133e283969a6d4 127.0.0.1:7005 slots: (0 slots) slave replicates e9df2796f7aaf6ccb8f1c0737b9a23cd0d1ccddf[OK] All nodes agree about slots configuration.&gt;&gt;&gt; Check for open slots...&gt;&gt;&gt; Check slots coverage...[OK] All 16384 slots covered. Redis客户端的使用redis-cli直接在终端输入redis-cli默认连接的是127.0.0.1:6379,如果在本地6379端口没有启动redis实例，将会报错1234[root@tuyu redis]# redis-cliCould not connect to Redis at 127.0.0.1:6379: Connection refusedCould not connect to Redis at 127.0.0.1:6379: Connection refusednot connected&gt; redis-cli -p 7000前提：本地在7000-7005端口分别启了一个redis实例，并将这些redis实例组成了一个redis集群连接本地7000端口的redis实例12[root@tuyu redis]# redis-cli -p 7000127.0.0.1:7000&gt; 以集群的方式连接redis服务器redis-cli -c -h 127.0.0.1 -p 7001 redis服务器的模式有三种 主从模式 哨兵模式 集群模式 主从模式，常见的有一主一从，一主多从主从模式的好处是：数据备份，读写分离，解决了流量瓶颈问题主从模式的缺点是：不能解决故障迁移问题 哨兵模式，在主从模式的基础上，额外起技术哥哨兵进程，让哨兵进程监视主节点，当主节点宕机后，通过投票机制选举一个从节点替代宕机的主节点，并让其他的从节点作为新的主节点的从节点哨兵模式的好处是：解决了主从模式没有解决的故障自动迁移的问题哨兵模式的缺点是：从节点下线了，不会对其进行故障迁移的 集群模式，将key映射到16384个hash槽里，集群中每个节点都分配部分hash槽，当客户端连接集群中的某个节点，并执行操作时，通过一致的hash算法，计算书key所对应的hash并对16384取模，再用得到的结果去映射到具体的集群节点，如果不是当前节点，操作将被重定向到具体的节点，redis集群是去中心化的，所有节点都是平等的，集群间通信使用goossip协议，为解决集群中某个节点下线后，对应的hash槽不可用的情况，可以为集群中的所有节点都设置一至多个从节点，当主节点下线后，从节点替代主节点集群模式的好处是：解决了单机内存限制，解决了流量瓶颈问题集群模式的缺点是：当某个节点与它的所有从节点都下线后，它所处理的hash槽都不可用了，需要人工介入，从新分配hash槽 参考链接https://www.jianshu.com/p/c869feb5581d https://ruby.taobao.org/ http://weizijun.cn/2016/01/08/redis%20cluster%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7redis-trib-rb%E8%AF%A6%E8%A7%A3/]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>Redis集群</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[io]]></title>
    <url>%2F2018%2F07%2F11%2Fio%2F</url>
    <content type="text"><![CDATA[概述 谈谈io与装饰者模式 io与装饰者模式首先，装饰者模式中装饰者和被装饰者都会继承同一个Component(抽象类或者接口)，通常情况，装饰者大多会直接继承一个抽象的装饰者Decorator，这个抽象的装饰者直接继承Component，且抽象装饰者中保存了被装饰者的一个引用，装饰者会将客户端所有的请求都应用到被装饰者上，并动态地增强被装饰者的属性或者功能。当然这个抽象的装饰者可以不存在，所有的具体装饰者直接继承Component，但是必须保存被装饰者的一个引用，区分具体被装饰者和具体装饰者的关键点就是看这个类是否有一个Component的一个引用，因为装饰者需要这个引用来动态的将请求应用到具体的被装饰着身上，以达到增强属性和功能的目的。装饰者的模式的优点： 扩展性好 可以针对Component扩展出很多具体的被装饰者concreteComponent，也可以针对Ddecorator扩展出很多具体的装饰者concreteDecorator 灵活性好 不同的具体装饰者和不同的具体被装饰者可以灵活组合，以实现丰富的功能 装饰者模式的缺点： 程序中会出现很多小类，即各种各样的具体装饰者和具体被装饰者 在java的io框架中有4个基类，分别是InputStream, OutputStream, Reader, Writer, 它们扮演着Component的角色，所有的被装饰者都会直接继承 直接继承InputStream的具体被装饰者有哪些？ 比如：FileInputStream, PipedInputStream, ByteArrayInputStream.直接继承OutputStream的具体被装饰者有哪些？ 比如：FileOutputStream, PipedOutputStream, ByteArrayOutputStream.直接继承Reader的具体被装饰者有哪些？ 比如：StringReader, CharArrayReader, PipedReader.直接继承Writer的具体被装饰者有哪些？ 比如：StringWriter, CharArrayWriter, PipedWriter. 装饰InputStream的具体装饰者（可以是抽象的类，也可以是具体的类）有哪些？ 比如：FilterInputStream,SequenceInputStream,BufferedInputStream和DataInputStream都继承自FilterInputStream,ObjectInputStream它内部保存了一个BlockDataInputStream的一个引用，它是一个继承InputStream的私有内部类，这些装饰者都是具体的装饰者，并非抽象类。 装饰OutputStream的具体装饰者（可以是抽象的类，也可以是具体的类）有哪些？ 比如：FilterInputStream,BufferedInputStream、DataOutputStream和PrintStream都继承自FilterInputStream,ObjectOutputStream它内部保存了一个BlockDataOutputStream的一个引用，它是一个继承OutputStream的私有内部类，这些装饰者都是具体的装饰者，并非抽象类。 装饰Reader的具体装饰者（可以是抽象的类，也可以是具体的类）有哪些？ 比如：FilterReader是一个抽象装饰者,BufferedReader是一个具体的装饰者,InputStreamReader是一个具体装饰者，它并没有直接保存Reader的引用，但是它保存了一个StreamDecoder的引用，而StreamDecoder是一个具体的被装饰者。 装饰Writer的具体装饰者（可以是抽象的类，也可以是具体的类）有哪些？ 比如：PrintWriter,BufferedWriter,OutputStreamWriter并没有直接保存Writer的引用，但是它保存了一个StreamEncoder的引用，而StreamEncoder是一个具体的被装饰者。 参考链接https://zhuanlan.zhihu.com/p/28286559]]></content>
  </entry>
  <entry>
    <title><![CDATA[nio]]></title>
    <url>%2F2018%2F07%2F02%2Fnio%2F</url>
    <content type="text"><![CDATA[概述 Buffer Buffer何谓Buffer? Buffer 是一个线性的有限长度的特定基本数据的序列。 除了基础数据外，它还包括一些基础操作和属性， 比如capacity, limit 和 position. 参考链接 Selector调用 Selector 的静态工厂创建一个选择器 参考链接]]></content>
  </entry>
  <entry>
    <title><![CDATA[jvm]]></title>
    <url>%2F2018%2F06%2F28%2Fjvm%2F</url>
    <content type="text"><![CDATA[概述 JVM运行时内存区域划分 内存溢出OOM和堆栈溢出SOE的示例及原因、如何排查与解决 如何判断对象是否可以回收或存活 常见的GC回收算法及其含义 常见的JVM性能监控和故障处理工具类：jps、jstat、jmap、jinfo、jconsole等 JVM如何设置参数 JVM性能调优 类加载器、双亲委派模型、一个类的生命周期、类是如何加载到JVM中的 类加载的过程：加载、验证、准备、解析、初始化 强引用、软引用、弱引用、虚引用 Java内存模型JMM 什么是Java内存模型 Java内存模型的作用是什么 JMM中内存间交互操作有哪些 JMM中有哪些规则 内存访问操作有有哪些特性 JVM运行时内存区域划分主要分为5个部分： 程序计数器 虚拟机栈 本地方法栈 方法区 堆 程序计数器Java是一门解释型的语言，java文件被javac编译成class的字节码文件，字节码解释器会将编译好的字节码文件解释执行，这也java语言可以很好的实现的跨平台的真正原因，而程序计数器中的值保存的是下一条将要被执行的执行的字节码指令的地址，每条线程都会有一个独立的程序计数器，各线程之间互不影响，独立存储。 java虚拟机栈虚拟机栈描述的是java方法执行的内存模型，方法的执行的同时会创建一个栈祯，用于存储方法中的局部变量表、操作数栈、动态链接、方法的出口等信息，每个方法从调用直到执行完成的过程，就对应着一个栈祯在虚拟机栈中入栈到出栈的过程。 本地方法栈本地方法栈与java虚拟机栈类似，也会抛出OutOfMemoryError,和StackOverflowError在HotSpot虚拟机中，本地方法栈和虚拟机栈合二为一 方法区方法区 堆java堆是java虚拟机所管理的内存中最大的一块，是所有线程共享的内存区域，主要用来保存对象实例，在虚拟机进程启动是创建，按照分带收集算法来说，java对可以细分为新生代和老年代，还可以细分为Edean空间、From Survivor空间，To Survivor空间，java对可以划分出多个线程私有的分配缓冲区，TLAB，进一步划分的目的是为了更好的内存回收，或者更快的内存分配，java堆可以处于物理上不连续的内存区域，逐流的虚拟机都将java堆实现成可扩展的，当java没有内存完成实例分配，且无法再扩展时，将会抛出OutOfMemoryError 内存溢出OOM和堆栈溢出SOE的示例及原因、如何排查与解决OOM示例java堆内存发生OOM原因: 程序中有大量的对象生成，并且这些对象不能被GC回收，当java堆不能为实例分配内存时就会发生内存溢出OOM排查: 在启动参数中加上-XX:+HeapDumpOnOutOfMemoryError，当发生内存溢出时，会dump当时的内存堆转储快照文件解决: 通过分析对转储快照文件，是内存溢出还是内存泄漏，如果是内存泄漏，根据泄漏的对象实例确定对象类型，以及GC roots的引用链，从而确定泄漏的代码；如果是内存溢出，查看java堆参数，是否能调大-Xms和-Xmx的值实验：vm args -Xms10M -Xmx10M -XX:+HeapDumpOnOutOfMemoryError1234567public static void main(String[] args)&#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); int i = 0; while(true)&#123; list.add(String.valueOf(i++)); &#125;&#125; 在JDK 1.8下运行结果如下:12345678java.lang.OutOfMemoryError: GC overhead limit exceededDumping heap to java_pid859.hprof ...Heap dump file created [12059282 bytes in 0.075 secs]Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: GC overhead limit exceededDisconnected from the target VM, address: &apos;127.0.0.1:50160&apos;, transport: &apos;socket&apos; at java.lang.Integer.toString(Integer.java:403) at java.lang.String.valueOf(String.java:3087) at com.tuyu.oom.JavaHeapOOM.main(JavaHeapOOM.java:47) 分析：参考链接垃圾回收器出现了异常 sun官方说明：并行/并发回收器在GC回收时间过长时会抛出OutOfMemroyError。过长的定义是，超过98%的时间用来做GC并且回收了不到2%的堆内存。用来避免内存过小造成应用不能正常工作。 SOE示例java虚拟机栈发生SOE原因：线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError排查：通过错误日志，定位发生SOE的代码解决：发生SOE一般是程序中出现了递归调用，检查代码递归是否写错，如果没有写错能否用尾递归优化代码，或者用迭代的方式替换递归算法，或者适当调整-Xss的大小，增大虚拟机允许的最大栈深度实验：vm args: -Xss160k1234567891011121314private static int i = 0;public static void main(String[] args)&#123; try&#123; hello(); &#125;catch(Throwable e)&#123; System.out.println("i = " + i); e.printStackTrace(); &#125;&#125;public static void hello()&#123; i++; hello();&#125; 在JDK 1.8下运行结果如下:1234i = 847java.lang.StackOverflowError at com.tuyu.oom.JavaHeapOOM.hello(JavaHeapOOM.java:54) .... 分析: 在我的电脑中运行此程序，递归调用了847次，160K的栈容量能够支持的栈的最大深度是847，这个也跟不同的方法有关，不同方法的栈帧大小不一 如何判断对象是否可以回收或存活常见的GC回收算法及其含义常见的JVM性能监控和故障处理工具类：jps、jstat、jmap、jinfo、jconsole等JVM如何设置参数JVM性能调优类加载器、双亲委派模型、一个类的生命周期、类是如何加载到JVM中的类加载的过程：加载、验证、准备、解析、初始化强引用、软引用、弱引用、虚引用java内存模型JMM是什么？Java内存模型规定了除线程私有变量外，所有的变量都保存在主内存中；其次每条线程都有自己的工作内存；然后，线程对变量的访问只能在工作内存，不能直接读写主内存中的变量；最后线程间无法直接访问对方工作内存中的变量，线程间变量值的传递需要通过主内存来完成 JMM的作用是什么？Java内存模型的作用是屏蔽各种硬件和操作系统间内存访问差异，以达到让java程序在平台能有一致的内存访问效果。 JMM中定义了哪些内存间交互操作？Java内存模型中定义8个内存间交互操作，分别是lock, unlock, read, write, use, assign, load, store, 前四个是作用在主内存中的，后四个是作用在线程工作内存中的。 JMM中有哪些规则对于volatile型变量的特殊访问规则，具体规则是：被volatile修饰的变量对于所有线程的可见性，禁止指令重排序优化 以及对于long、double的特殊访问规则，具体规则是：long、double的非原子性协定，允许Java虚拟机实现不保证64位数据类型的read, write, load, store操作的原子性。 内存访问有哪些特性？原子性， 可见性， 有序性说说我对原子性的理解：大多数基本数据类型变量的访问读写操作都是原子性的，Java内存模型提供的8个内存交互操作都是原子性的，其中lock, unlock操作提供了更大范围的原子性，这两个操作对应到字节码层面就是monitorenter和monitorexit,对应到java代码中就是synchronized同步代码块，所以说synchronized代码块之间的操作都是原子性的。 说说我对可见性的理解：可见性java内存模型，即JMM，java虚拟机规范定义了一种java内存模型来屏蔽掉各种硬件和操作系统之间的内存访问差异，使得java程序在各平台上有一致的内存访问效果java程序中除线程私有变量之外的所有变量都保存在主内存之中每条线程都有自己的工作内存，存放线程的私有变量（比如局部变量、方法参数、以及被线程使用到的变量值的主内存的副本拷贝）线程对变量的所有操作都必须在工作内存中进行，不能直接读写主内存中的变量线程间无法直接访问对方的工作内存，线程间值的传递必须通过主内存完成JMM定义了8个操作来完成变量从主内存拷贝到工作内存，从工作内存同步回主内存，分别是：lock, unlock, read, load, use, assign, store, writeJMM还定义了许多规则比如：对于volatile型变量的特殊规则 保证了被volatile修饰的变量对所有线程的可见性 禁止指令重排序优化这里的可见性指的是：当一个线程修改了共享变量的值，新值对于其他线程来说是立即可见的禁止指令重排序优化，引出了双锁检测实现单例12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Instance&#123; private static volatile Instance instance; private Instance()&#123;&#125; public static Instance getInstance()&#123; if(instance == null)&#123; synchronized(Instance.class)&#123; if(instance == null)&#123; instance = new Instance(); &#125; &#125; &#125; return instance; &#125;&#125;对于long,double型变量的特殊规则非原子性协定指的是允许java虚拟机实现可以不保证64为数据类型的load, store, read, write的原子性并发当中的三个特性：原子性可见性有序性大致可以认为所有基本类型的变量读写操作都是原子性的，例外情况就是非原子性协定，几乎不会出现，JMM提供了read, load, use, assign, store, write操作保证边变量的原子性对于更大范围的原子性保证，JMM提供了lock, unlock操作，它们对应与java字节码指令是moniterenter和mointerexit,而这两个字节码对应与java代码中的synchronized关键字，所以sychronized代码块之间的操作也是原子性的可见性指的是，当一个线程修改了共享变量的值，新值对于其他线程来说是立即可见的，前面已经说过，volatile变量的特殊规则保证了新值能立即同步到主内存，及要使用前能立即从主内存刷新。对于可见性，java语言提供了3个关键字，synchronized, volatile, final有序性指的是，在线程中观察，所有代码都是有序的；在一个线程中观察另一个线程，所有代码都是无序的。前半句指的是程序内表现为串行语义，后半句指的是指令重排序和工作内存到主内存的同步延迟先行发生原则指的是JMM中定义的两个操作之间的偏序关系，如果操作A现行发生于操作B，也就是说在操作B发生之前，操作A产生的影响被操作B来观察到该原则的作用是，判断数据是否存在竞争，线程是否安全JMM中8中先行发生关系程序次序原则管程锁定原则volatile变量原则线程启动原则线程终止原则线程中断原则对象终结原则传递性原则 参考链接]]></content>
  </entry>
  <entry>
    <title><![CDATA[beanFactory]]></title>
    <url>%2F2018%2F06%2F26%2FbeanFactory%2F</url>
    <content type="text"><![CDATA[概述 参考链接]]></content>
  </entry>
  <entry>
    <title><![CDATA[消息队列]]></title>
    <url>%2F2018%2F05%2F31%2F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[概述 为什么要使用消息队列? 使用了消息队列会有什么缺点? 消息队列如何选型? 如何保证消息队列是高可用的？ 如何保证消息不被重复消费？ 如何保证消费的可靠性传输? 如何保证消息的顺序性？ 为什么要使用消息队列解耦异步削峰使用了消息队列会有什么缺点系统可用性降低系统复杂性增加消息队列如何选型中小型软件公司，建议选RabbitMQ大型软件公司，根据具体使用在rocketMq和kafka之间二选一如何保证消息队列是高可用的消息队列的集群模式 如何保证消息不被重复消费 or 如何保证消息队列的幂等性原因：网络传输等等故障，确认信息没有传送到消息队列，导致消息队列不知道自己已经消费过该消息了，再次将该消息分发给其他的消费者 如何保证消费的可靠性传输其实这个可靠性传输，每种MQ都要从三个角度来分析:生产者弄丢数据、消息队列弄丢数据、消费者弄丢数据 生产者发送数据，开启事务 消息队列持久化数据之后再向生产者确认 消费者消费成功之后确认消息，不要采用自动确认的消息模式 如何保证消息的顺序性通过某种算法，将需要保持先后顺序的消息放到同一个消息队列中(kafka中就是partition,rabbitMq中就是queue)。然后只用一个消费者去消费该队列。保证入队有序就行，出队以后的顺序交给消费者自己去保证，没有固定套路 参考链接https://mp.weixin.qq.com/s?__biz=MzU0OTE4MzYzMw==&amp;mid=2247484799&amp;idx=1&amp;sn=bc98c5b88a276ce113de633800b6cdb8&amp;chksm=fbb28c81ccc505974e163faf38afc08ecafe6ae3c68b8b3d9993c214650dc7b4fe75c49006ac&amp;mpshare=1&amp;scene=23&amp;srcid=0531L6FSQOszDoWxcyQM1Hfj%23rd]]></content>
  </entry>
  <entry>
    <title><![CDATA[成为java高级程序员需要掌握哪些]]></title>
    <url>%2F2018%2F05%2F31%2F%E6%88%90%E4%B8%BAjava%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E5%93%AA%E4%BA%9B%2F</url>
    <content type="text"><![CDATA[概述 参考链接https://mp.weixin.qq.com/s?__biz=MzA3ODQ0Mzg2OA==&amp;mid=2649047703&amp;idx=1&amp;sn=d04a7427d89708016dcb7400529328f1&amp;chksm=875346a4b024cfb2f67810df77722a885cf4732ef8cf17f6fcfb52ac690d5b4a6c585c79a145&amp;mpshare=1&amp;scene=23&amp;srcid=0531ilcdBgUXBf2LGI5B7so4%23rd]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[分布式事务]]></title>
    <url>%2F2018%2F05%2F30%2F%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[概述 在编程中.一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同 参考链接https://www.i3geek.com/archives/841https://www.i3geek.com/archives/841https://www.jianshu.com/p/21f7fdfd9906]]></content>
      <categories>
        <category>Transction</category>
      </categories>
      <tags>
        <tag>事务</tag>
        <tag>分布式</tag>
        <tag>分布式事务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DDos攻击]]></title>
    <url>%2F2018%2F05%2F23%2FDDos%E6%94%BB%E5%87%BB%2F</url>
    <content type="text"><![CDATA[概述DDos攻击，即分布式拒绝服务 DDos攻击的原理 如何防御DDos攻击 DDos攻击的原理它是利用TCP连接三次握手的原理，发送大量的建立连接的网络包，但不实际建立连接，最终导致被攻击服务器的网络队列被占满，服务被正常用户访问。 如何防御DDos攻击 充分利用网络设备保护网络资源，比如路由器限制SYN/ICMP的最大流量，防火墙限制特定IP，过滤攻击时伪造的大量虚假内部IP（Internet内部保留的区域性IP地址），启用防火墙的防DDos属性 服务器自身定期扫描安全漏洞，升级补丁，关闭不必要的服务，限制最大SYN半连接数目，缩短SYN半连接time out时间等参考链接 https://blog.csdn.net/huwei2003/article/details/45476743 https://www.jianshu.com/p/cacfe5749e81]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java动态代理]]></title>
    <url>%2F2018%2F05%2F22%2FJava%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[概述 Java的动态代理，是指利用Java反射技术在运行期创建实现某些特定接口的新类及其实例，代理的是接口，不是抽象类，更不是类。 动态代理的作用 动态代理的作用 一个接口的实现在编译时无法知道，需要在运行时才能实现 实现适配器模式、装饰者模式等设计模式 面向切面编程，AOP技术 参考链接https://www.cnblogs.com/techyc/p/3455950.html]]></content>
      <categories>
        <category>JDK</category>
        <category>Proxy</category>
      </categories>
      <tags>
        <tag>动态代理</tag>
        <tag>Proxy</tag>
        <tag>Reflection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zookeeper简介]]></title>
    <url>%2F2018%2F05%2F18%2Fzookeeper%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[概述 什么是zookeeper? 什么是分布式系统？zookeeper是一个中间件，为分布式系统提供协调服务分布式系统就是很多台计算机组成一个整体，一致对外并且处理同一个请求；内部每台计算机都可以相互通信（rest/rpc);客户端到服务端的一次请求到相应结束会经历对台计算机 分布式文件系统——俗称网盘 参考链接]]></content>
      <categories>
        <category>ZooKeeper</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[volatile的实现原理]]></title>
    <url>%2F2018%2F05%2F16%2Fvolatile%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[概述 volatile的两个语义 volatile的两个语义是什么 保证变量对所有线程的可见性 禁止机器级别的指令重排序优化 volatile如何保证变量对所有线程的可见性的当一个变量被volatile关键字修饰之后，如果某个线程修改了该变量的值，其他线程会得到更新通知，其他线程在使用该变量时就会去主内存中刷新该变量的值 volatile是如何禁止机器级别的指令重排序优化的通过反汇编机器指令，可以看到被volatile修饰的变量在赋值后多了一个lock操作，这个操作相当于一个内存屏障，重排序时不能把lock之后的指令重排序到lock之前，对应到DCL例子来说，就是返回实例对象这个操作对应的指令不能在给volatile变量赋值之前执行，保证了其他线程拿到实例对象是可用的，是已经正确实例化的对象 参考链接《深入理解Java虚拟机·JVM高级特性与最佳实践》第12章 Java内存模型与线程 12.3.4节]]></content>
      <categories>
        <category>JDK</category>
        <category>Concurrent</category>
      </categories>
      <tags>
        <tag>Concurrent</tag>
        <tag>volatile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[信号Signal和信号量Semaphore]]></title>
    <url>%2F2018%2F05%2F16%2F%E4%BF%A1%E5%8F%B7Signal%E5%92%8C%E4%BF%A1%E5%8F%B7%E9%87%8FSemaphore%2F</url>
    <content type="text"><![CDATA[参考链接https://blog.csdn.net/langjian2012/article/details/39717903 http://www.importnew.com/22519.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[JDK常用的命令行工具]]></title>
    <url>%2F2018%2F05%2F15%2FJDK%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[参考链接http://www.importnew.com/18398.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[Thread的生命周期]]></title>
    <url>%2F2018%2F05%2F15%2FThread%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[概述 Java的Thread生命周期中有几个状态？ Java的Thread生命周期中的状态是怎么转换的？ Java的Thread生命周期中有6个状态参考JDK API 1.8 java.lang.Thread.State NEW 新建状态，还没有执行Thread.start()方法时所处的状态 RUNNABLE 可执行状态，在等待系统资源，比如处理器 BLOCKED 阻塞状态，线程在同步代码块中等待获取锁 WAITING 等待状态，当线程调用了如下的方法时就会进入该状态，比如：调用Object.wait()没有超时, Thread.join()没有超时, LockSupport.park() TIMED_WAITING 超时等待状态，当线程调用了如下的方法时就会进入该状态，比如：调用Object.wait(long), Thread.join(long), LockSuport.parkNanos(), LockSupport.parkUntil() TERMINATED 终止状态，线程运行完run（）方法之后就会进入该状态 这里有个疑问： 为什么BLOCKED状态是在线程调用了Objcet.wait()方法之后进入的，而WAITING状态也是线程调用Object.wait()方法进入的，那当线程调用Object.wait()方法之后是进入BLOCKED状态呢，还是进入WAITING状态呢？ Java的Thread生命周期中的状态是怎么转换的？参考链接https://www.zhihu.com/question/27654579]]></content>
      <categories>
        <category>JDK</category>
        <category>Thread</category>
      </categories>
      <tags>
        <tag>JDK</tag>
        <tag>Thread</tag>
        <tag>wait</tag>
        <tag>notify</tag>
        <tag>join</tag>
        <tag>sleep</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[队列相关问题]]></title>
    <url>%2F2018%2F05%2F14%2F%E9%98%9F%E5%88%97%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[概述 LinkedBlockingQueue的实现原理 ArrayBlockingQueue的实现原理 SynchronousQueue的实现原理 BlockingQueue提供的方法分析 抛出异常 返回特殊值 一直阻塞 超时退出 插入方法 add(e) offer(e) put(e) offer(e, time unit) 移除方法 remove() poll() take() poll(time, unit) 检查方法 element() peek() - - LinkedBlockingQueue的实现原理 LinkedBlockingQueue在构造时可以指定队列大小，如果不指定，默认使用Integer.MAX_VALUE; add方法继承自AbstractQueue,实质上是调用offer方法向队列中加入元素，不管是offer还是put都不允许被加入的元素是null，否则将抛出空指针异常； 内部有两把重入锁，分别是putLock和takeLock,还有两个条件,分别是putLock创建的notFull,以及takeLock创建的notEmpty,不同的锁对应元素的入队和出队操作，提高并发的效率，比如putLock锁在生产者向队列添加元素时起作用，而takeLock锁在消费者在队列获取元素时起作用；不同的条件，可以通知不同的线程，比如notEmpty条件会通知所有消费者线程，notFull条件会通知所有生产者线程 LinkedBlockingQueue类图 ArrayBlockingQueue的实现原理ArrayBlockingQueue类图 SynchronousQueue的实现原理SynchronousQueue类图 参考链接https://segmentfault.com/a/1190000004911771 https://www.cnblogs.com/lyysz/p/5913264.html]]></content>
      <categories>
        <category>JDK</category>
        <category>Collections</category>
        <category>Queue</category>
      </categories>
      <tags>
        <tag>List</tag>
        <tag>LinkedList</tag>
        <tag>BlockingQueue</tag>
        <tag>Queue</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的反斜杠0是什么意思]]></title>
    <url>%2F2018%2F05%2F11%2FJava%E4%B8%AD%E7%9A%84%E5%8F%8D%E6%96%9C%E6%9D%A00%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%2F</url>
    <content type="text"><![CDATA[概述Java中char a = &#39;\0&#39;;给一个字符变量赋值为&#39;\0&#39;表示什么意思？char a = &#39;0&#39;又表示什么意思？ 参考链接https://www.jiuzhang.com/qa/3583/ https://bbs.csdn.net/topics/390544484 http://ascii.911cha.com/]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>char</tag>
        <tag>字符变量</tag>
        <tag>ASCII码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell脚本批量发送POST请求]]></title>
    <url>%2F2018%2F05%2F10%2FShell%E8%84%9A%E6%9C%AC%E6%89%B9%E9%87%8F%E5%8F%91%E9%80%81POST%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[概述 重点eval命令行前面放eval，在执行命令之前，它将被扫描两次 12pipe="|"eval ls $pipe wc -c shell第1次扫描命令行时，它替换出pipe的值｜，接着eval使它再次扫描命令行，这时shell把｜作为管道符号了。 如果变量中包含任何需要shell直接在命令行中看到的字符（不是替换的结果），就可以使用eval。命令行结束符（；｜ &amp;），I／o重定向符（&lt; &gt;）和引号就属于对shell具有特殊意义的符号，必须直接出现在命令行中。 源码1234567891011121314151617181920212223242526272829#! /bin/baship=10.12.102.134port=7080cat data | while read ido line=$i source_id=`echo $line | cut -d ' ' -f 1` item_code=`echo $line | cut -d ' ' -f 2` description=`echo $line | cut -d ' ' -f 3` address=`echo $line | cut -d ' ' -f 4` area_code=`echo $line | cut -d ' ' -f 5` longitude=`echo $line | cut -d ' ' -f 6` latitude=`echo $line | cut -d ' ' -f 7` echo $source_id echo $item_code echo $description echo $address echo $area_code echo $longitude echo $latitude send_data='&#123;"sourceId":"'$source_id'", "itemCode":"'$item_code'", "description":"'$description'", "address":"'$address'","areaCode":"'$area_code'", "longitude":"'$longitude'", "latitude":"'$latitude'","files":[], "data":&#123;&#125;&#125;' send_data="'"$send_data"'" param=' -d '$send_data command='curl -X POST http://'$ip':'$port'/dcm-web/caseApi/addCase.json -H "Content-Type:application/json"'$param # curl -X POST http://$ip:$port/dcm-web/caseApi/addCase.json -H "Content-Type: application/json" $param echo $command eval $commanddone 参考链接http://www.cnblogs.com/dwdxdy/archive/2012/07/25/2608816.html http://blog.zengrong.net/post/1591.html https://droidyue.com/blog/2014/07/02/send-post-request-using-curl/ https://blog.csdn.net/wanruirui/article/details/5975867 http://blog.51cto.com/363918/1341977]]></content>
      <categories>
        <category>Linux</category>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Bash</tag>
        <tag>for循环</tag>
        <tag>curl</tag>
        <tag>post</tag>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[其他面试相关问题]]></title>
    <url>%2F2018%2F05%2F10%2F%E5%85%B6%E4%BB%96%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1.4、锁机制说说线程安全问题，什么是线程安全，如何保证线程安全 重入锁的概念，重入锁为什么可以防止死锁 产生死锁的四个条件（互斥、请求与保持、不剥夺、循环等待） 如何检查死锁（通过jConsole检查死锁） volatile 实现原理（禁止指令重排、刷新内存） synchronized 实现原理（对象监视器） synchronized 与 lock 的区别 AQS同步队列 CAS无锁的概念、乐观锁和悲观锁 常见的原子操作类 什么是ABA问题，出现ABA问题JDK是如何解决的 乐观锁的业务场景及实现方式 Java 8并法包下常见的并发类 偏向锁、轻量级锁、重量级锁、自旋锁的概念 1.5、JVMJVM运行时内存区域划分 内存溢出OOM和堆栈溢出SOE的示例及原因、如何排查与解决 如何判断对象是否可以回收或存活 常见的GC回收算法及其含义 常见的JVM性能监控和故障处理工具类：jps、jstat、jmap、jinfo、jconsole等 JVM如何设置参数 JVM性能调优 类加载器、双亲委派模型、一个类的生命周期、类是如何加载到JVM中的 类加载的过程：加载、验证、准备、解析、初始化 强引用、软引用、弱引用、虚引用 Java内存模型JMM 1.6、设计模式常见的设计模式 设计模式的的六大原则及其含义 常见的单例模式以及各种实现方式的优缺点，哪一种最好，手写常见的单利模式 设计模式在实际场景中的应用 Spring中用到了哪些设计模式 MyBatis中用到了哪些设计模式 你项目中有使用哪些设计模式 说说常用开源框架中设计模式使用分析 动态代理很重要！！！ 1.7、数据结构 树（二叉查找树、平衡二叉树、红黑树、B树、B+树） 深度有限算法、广度优先算法 克鲁斯卡尔算法、普林母算法、迪克拉斯算法 什么是一致性Hash及其原理、Hash环问题 常见的排序算法和查找算法：快排、折半查找、堆排序等 1.8、网络/IO基础BIO、NIO、AIO的概念 什么是长连接和短连接 Http1.0和2.0相比有什么区别，可参考《Http 2.0》 Https的基本概念 三次握手和四次挥手、为什么挥手需要四次 从游览器中输入URL到页面加载的发生了什么？可参考《从输入URL到页面加载发生了什么》 二、数据存储和消息队列 2.1、数据库MySQL 索引使用的注意事项 DDL、DML、DCL分别指什么 explain命令 left join，right join，inner join 数据库事物ACID（原子性、一致性、隔离性、持久性） 事物的隔离级别（读未提交、读以提交、可重复读、可序列化读） 脏读、幻读、不可重复读 数据库的几大范式 数据库常见的命令 说说分库与分表设计 分库与分表带来的分布式困境与应对之策（如何解决分布式下的分库分表，全局表？） 说说 SQL 优化之道 MySQL遇到的死锁问题、如何排查与解决 存储引擎的 InnoDB与MyISAM区别，优缺点，使用场景 索引类别（B+树索引、全文索引、哈希索引）、索引的原理 什么是自适应哈希索引（AHI） 为什么要用 B+tree作为MySQL索引的数据结构 聚集索引与非聚集索引的区别 遇到过索引失效的情况没，什么时候可能会出现，如何解决 limit 20000 加载很慢怎么解决 如何选择合适的分布式主键方案 选择合适的数据存储方案 常见的几种分布式ID的设计方案 常见的数据库优化方案，在你的项目中数据库如何进行优化的 2.2、RedisRedis 有哪些数据类型，可参考《Redis常见的5种不同的数据类型详解》 Redis 内部结构 Redis 使用场景 Redis 持久化机制，可参考《使用快照和AOF将Redis数据持久化到硬盘中》 Redis 集群方案与实现 Redis 为什么是单线程的？ 缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级 使用缓存的合理性问题 Redis常见的回收策略 2.3、消息队列消息队列的使用场景 消息的重发补偿解决思路 消息的幂等性解决思路 消息的堆积解决思路 自己如何实现消息队列 如何保证消息的有序性 三、开源框架和容器3.1、SSM/ServletServlet的生命周期 转发与重定向的区别 BeanFactory 和 ApplicationContext 有什么区别 Spring Bean 的生命周期 Spring IOC 如何实现 Spring中Bean的作用域，默认的是哪一个 说说 Spring AOP、Spring AOP 实现原理 动态代理（CGLib 与 JDK）、优缺点、性能对比、如何选择 Spring 事务实现方式、事务的传播机制、默认的事务类别 Spring 事务底层原理 Spring事务失效（事务嵌套），JDK动态代理给Spring事务埋下的坑，可参考《JDK动态代理给Spring事务埋下的坑！》 如何自定义注解实现功能 Spring MVC 运行流程 Spring MVC 启动流程 Spring 的单例实现原理 Spring 框架中用到了哪些设计模式 Spring 其他产品（Srping Boot、Spring Cloud、Spring Secuirity、Spring Data、Spring AMQP 等） 有没有用到Spring Boot，Spring Boot的认识、原理 MyBatis的原理 可参考《为什么会有Spring》 可参考《为什么会有Spring AOP》 3.2、Netty为什么选择 Netty 说说业务中，Netty 的使用场景 原生的 NIO 在 JDK 1.7 版本存在 epoll bug 什么是TCP 粘包/拆包 TCP粘包/拆包的解决办法 Netty 线程模型 说说 Netty 的零拷贝 Netty 内部执行流程 Netty 重连实现 3.3、Tomcat Tomcat的基础架构（Server、Service、Connector、Container） Tomcat如何加载Servlet的 Pipeline-Valve机制 可参考：《四张图带你了解Tomcat系统架构！》 四、分布式4.1、Nginx请解释什么是C10K问题或者知道什么是C10K问题吗？ Nginx简介，可参考《Nginx简介》 正向代理和反向代理. Nginx几种常见的负载均衡策略 Nginx服务器上的Master和Worker进程分别是什么 使用“反向代理服务器”的优点是什么? 4.2、分布式其他谈谈业务中使用分布式的场景 Session 分布式方案 Session 分布式处理 分布式锁的应用场景、分布式锁的产生原因、基本概念 分布是锁的常见解决方案 分布式事务的常见解决方案 集群与负载均衡的算法与实现 说说分库与分表设计，可参考《数据库分库分表策略的具体实现方案》 分库与分表带来的分布式困境与应对之策 4.3、Dubbo 什么是Dubbo，可参考《Dubbo入门》 什么是RPC、如何实现RPC、RPC 的实现原理，可参考《基于HTTP的RPC实现》 Dubbo中的SPI是什么概念 Dubbo的基本原理、执行流程 五、微服务 5.1、微服务 前后端分离是如何做的？ 微服务哪些框架 Spring Could的常见组件有哪些？可参考《Spring Cloud概述》 领域驱动有了解吗？什么是领域驱动模型？充血模型、贫血模型 JWT有了解吗，什么是JWT，可参考《前后端分离利器之JWT》 你怎么理解 RESTful 说说如何设计一个良好的 API 如何理解 RESTful API 的幂等性 如何保证接口的幂等性 说说 CAP 定理、BASE 理论 怎么考虑数据一致性问题 说说最终一致性的实现方案 微服务的优缺点，可参考《微服务批判》 微服务与 SOA 的区别 如何拆分服务、水平分割、垂直分割 如何应对微服务的链式调用异常 如何快速追踪与定位问题 如何保证微服务的安全、认证 5.2、安全问题如何防范常见的Web攻击、如何方式SQL注入 服务端通信安全攻防 HTTPS原理剖析、降级攻击、HTTP与HTTPS的对比 5.3、性能优化性能指标有哪些 如何发现性能瓶颈 性能调优的常见手段 说说你在项目中如何进行性能调优 六、其他6.1、设计能力说说你在项目中使用过的UML图 你如何考虑组件化、服务化、系统拆分 秒杀场景如何设计 可参考：《秒杀系统的技术挑战、应对策略以及架构设计总结一二！》 6.2、业务工程说说你的开发流程、如何进行自动化部署的 你和团队是如何沟通的 你如何进行代码评审 说说你对技术与业务的理解 说说你在项目中遇到感觉最难Bug，是如何解决的 介绍一下工作中的一个你认为最有价值的项目，以及在这个过程中的角色、解决的问题、你觉得你们项目还有哪些不足的地方 6.3、软实力说说你的优缺点、亮点 说说你最近在看什么书、什么博客、在研究什么新技术、再看那些开源项目的源代码 说说你觉得最有意义的技术书籍 工作之余做什么事情、平时是如何学习的，怎样提升自己的能力 说说个人发展方向方面的思考 说说你认为的服务端开发工程师应该具备哪些能力 说说你认为的架构师是什么样的，架构师主要做什么 如何看待加班的问题 zookeeper的watcher乐观锁怎么实现 一个项目的整个流程 说出一个空间换时间的场景 centos7的内存分配方式和6有啥不同 你对公司有什么价值 kafka为什么性能这么好 G1和CMS的区别，G1有啥劣势 Kafka的整体架构 Netty的一次请求过程 自旋锁/偏向锁/轻量级锁 hbase线上问题排查 求一棵树两个节点的最近的公共父节点 HTTP 301 302有啥区别 设计一个短链接算法 md5长度是多少 ThreadLocal如果引用一个static变量是不是线程安全的？ netty的写流程 redis数据结构的实现，字符串是怎么实现的，有什么优势 求一棵树所有左叶子节点的和 给定一个值K，一个数列，求数列中两个值a和b，使得a+b=k kafka的结构 怎么防止订单重复提交 缓存同步问题 istio，介绍了设计理念 lambda表达式怎么来的，我从lambda演算说到lisp说到scala 如何保证日志上传的幂等性，如何在保证幂等的前提下提高性能 问我有没有什么要了解的，花了十几分钟介绍他们现在做的事情、技术栈、未来的一些计划, 项目使用JDK8吗，有使用Stream，Lambda等新特性吗 如何实现分布式锁、如何保证幂等性、分布式事务的解决方案 分布式锁的缺点，我说性能会出现瓶颈 一致性hash如何保证负载均衡 kafka和rocketmq各自的优缺点 dubbo的一个请求过程、序列化方式 序列化框架、PB的缺点、如何从数据库大批量导入数据到hbase 何保证消息幂等性 参考链接https://mp.weixin.qq.com/s?__biz=MzA3ODQ0Mzg2OA==&amp;mid=2649047626&amp;idx=1&amp;sn=51772d16d8a09e5bbbd9985acdd8f91c&amp;chksm=87534679b024cf6fef68b47c706f7fd6d977e5621cea478ddf7b64087b7a039eb52eaf748d12&amp;mpshare=1&amp;scene=23&amp;srcid=0510pOnjDH6eemO4NEjdi3RK%23rd https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&amp;mid=2247484900&amp;idx=1&amp;sn=e3bfb1f5220282bc3578afbb42d2424a&amp;chksm=ebf6dd9bdc81548d6ab47291ca101ce86f936f5bec66edc50f023272d3eb1432bb960c0cee8b&amp;mpshare=1&amp;scene=23&amp;srcid=0530CyFjMU6iegbK9D4aCs9T%23rd]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[线程的生命周期，状态是如何转移的]]></title>
    <url>%2F2018%2F05%2F10%2F%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%8C%E7%8A%B6%E6%80%81%E6%98%AF%E5%A6%82%E4%BD%95%E8%BD%AC%E7%A7%BB%E7%9A%84%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[线程池的几种实现方式]]></title>
    <url>%2F2018%2F05%2F10%2F%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[讲讲线程池的实现原理]]></title>
    <url>%2F2018%2F05%2F10%2F%E8%AE%B2%E8%AE%B2%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[ThreadLocal 原理分析，ThreadLocal为什么会出现OOM，出现的深层次原理]]></title>
    <url>%2F2018%2F05%2F10%2FThreadLocal-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%EF%BC%8CThreadLocal%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0OOM%EF%BC%8C%E5%87%BA%E7%8E%B0%E7%9A%84%E6%B7%B1%E5%B1%82%E6%AC%A1%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[说说 Exchanger 原理]]></title>
    <url>%2F2018%2F05%2F10%2F%E8%AF%B4%E8%AF%B4-Exchanger-%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[说说 Semaphore 原理]]></title>
    <url>%2F2018%2F05%2F10%2F%E8%AF%B4%E8%AF%B4-Semaphore-%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[说说 CountDownLatch、CyclicBarrier 原理和区别]]></title>
    <url>%2F2018%2F05%2F10%2F%E8%AF%B4%E8%AF%B4-CountDownLatch%E3%80%81CyclicBarrier-%E5%8E%9F%E7%90%86%E5%92%8C%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[进程间通信的方式]]></title>
    <url>%2F2018%2F05%2F10%2F%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[创建线程的方式及实现]]></title>
    <url>%2F2018%2F05%2F10%2F%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[线程和进程的概念、并行和并发的概念]]></title>
    <url>%2F2018%2F05%2F10%2F%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5%E3%80%81%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91%E7%9A%84%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[手写简单的HashMap]]></title>
    <url>%2F2018%2F05%2F10%2F%E6%89%8B%E5%86%99%E7%AE%80%E5%8D%95%E7%9A%84HashMap%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[ConcurrentHashMap 的工作原理及代码实现，如何统计所有的元素个数]]></title>
    <url>%2F2018%2F05%2F10%2FConcurrentHashMap-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%8C%E5%A6%82%E4%BD%95%E7%BB%9F%E8%AE%A1%E6%89%80%E6%9C%89%E7%9A%84%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[概述 ConcurrentHashMap在JDK7和JDK8中有什么不同？ 简述 参考链接]]></content>
  </entry>
  <entry>
    <title><![CDATA[HashMap出现Hash DOS攻击的问题]]></title>
    <url>%2F2018%2F05%2F10%2FHashMap%E5%87%BA%E7%8E%B0Hash-DOS%E6%94%BB%E5%87%BB%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[多线程情况下HashMap死循环的问题]]></title>
    <url>%2F2018%2F05%2F10%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%83%85%E5%86%B5%E4%B8%8BHashMap%E6%AD%BB%E5%BE%AA%E7%8E%AF%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[HashMap 的工作原理及代码实现，什么时候用到红黑树]]></title>
    <url>%2F2018%2F05%2F10%2FHashMap-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E5%88%B0%E7%BA%A2%E9%BB%91%E6%A0%91%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[HashMap 和 ConcurrentHashMap 的区别]]></title>
    <url>%2F2018%2F05%2F10%2FHashMap-%E5%92%8C-ConcurrentHashMap-%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[HashSet 和 HashMap 区别]]></title>
    <url>%2F2018%2F05%2F10%2FHashSet-%E5%92%8C-HashMap-%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[HashMap 和 Hashtable 的区别]]></title>
    <url>%2F2018%2F05%2F10%2FHashMap-%E5%92%8C-Hashtable-%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[ArrayList 与 Vector 区别]]></title>
    <url>%2F2018%2F05%2F10%2FArrayList-%E4%B8%8E-Vector-%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Arraylist 与 LinkedList 区别]]></title>
    <url>%2F2018%2F05%2F10%2FArraylist-%E4%B8%8E-LinkedList-%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[List 和 Map 区别]]></title>
    <url>%2F2018%2F05%2F10%2FList-%E5%92%8C-Map-%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Set和hashCode以及equals方法的联系]]></title>
    <url>%2F2018%2F05%2F10%2FSet%E5%92%8ChashCode%E4%BB%A5%E5%8F%8Aequals%E6%96%B9%E6%B3%95%E7%9A%84%E8%81%94%E7%B3%BB%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[List 和 Set 区别]]></title>
    <url>%2F2018%2F05%2F10%2FList-%E5%92%8C-Set-%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"></content>
      <categories>
        <category>JDK</category>
        <category>Set</category>
      </categories>
      <tags>
        <tag>Set</tag>
        <tag>HashSet</tag>
        <tag>TreeSet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 8有哪些新特性]]></title>
    <url>%2F2018%2F05%2F10%2FJava-8%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[JDK和JRE的区别]]></title>
    <url>%2F2018%2F05%2F10%2FJDK%E5%92%8CJRE%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Java的平台无关性如何体现出来的]]></title>
    <url>%2F2018%2F05%2F10%2FJava%E7%9A%84%E5%B9%B3%E5%8F%B0%E6%97%A0%E5%85%B3%E6%80%A7%E5%A6%82%E4%BD%95%E4%BD%93%E7%8E%B0%E5%87%BA%E6%9D%A5%E7%9A%84%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Object类中常见的方法，为什么wait notify会放在Object里边？]]></title>
    <url>%2F2018%2F05%2F10%2FObject%E7%B1%BB%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88wait-notify%E4%BC%9A%E6%94%BE%E5%9C%A8Object%E9%87%8C%E8%BE%B9%EF%BC%9F%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[什么是Java序列化和反序列化，如何实现Java序列化？或者请解释Serializable 接口的作用]]></title>
    <url>%2F2018%2F05%2F10%2F%E4%BB%80%E4%B9%88%E6%98%AFJava%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0Java%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9F%E6%88%96%E8%80%85%E8%AF%B7%E8%A7%A3%E9%87%8ASerializable-%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BD%9C%E7%94%A8%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[hashCode和equals方法的区别与联系]]></title>
    <url>%2F2018%2F05%2F10%2FhashCode%E5%92%8Cequals%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[equals与==的区别]]></title>
    <url>%2F2018%2F05%2F10%2Fequals%E4%B8%8E-%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[MVC设计思想]]></title>
    <url>%2F2018%2F05%2F10%2FMVC%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[列出自己常用的JDK包]]></title>
    <url>%2F2018%2F05%2F10%2F%E5%88%97%E5%87%BA%E8%87%AA%E5%B7%B1%E5%B8%B8%E7%94%A8%E7%9A%84JDK%E5%8C%85%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Session与Cookie区别]]></title>
    <url>%2F2018%2F05%2F10%2FSession%E4%B8%8ECookie%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[HTTP请求的GET与POST方式的区别]]></title>
    <url>%2F2018%2F05%2F10%2FHTTP%E8%AF%B7%E6%B1%82%E7%9A%84GET%E4%B8%8EPOST%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[说说自定义注解的场景及实现]]></title>
    <url>%2F2018%2F05%2F10%2F%E8%AF%B4%E8%AF%B4%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%9C%BA%E6%99%AF%E5%8F%8A%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[概述 Java注解基本知识 如何访问注解 Java注解基本知识 注解是代码的附属信息，不能干扰代码的正常执行，无论删除或增加注解，代码都能够正常执行 定义注解使用@interface修饰符 Java预定义注解被称为元注解，它们被Java编译器使用，比如：@Retention注解和@Target注解，前者定义注解的保留期限，后者定义注解的应用目标 注解的成员声明和接口的方法声明类似，还可以使用default关键字指定成员的默认值 如果注解只有一个成员，则成员名必须取名为value(),使用时如果给成员赋值可以不写成员名和赋值符号’=’ 如果注解有多个成员，在赋值时如果只给value()成员赋值，也可以不写成员名和赋值符号’=’ 如果在赋值时要同时给多个成员赋值，则必须写成员名和赋值符号’=’ 所有注解类都隐式继承与java.lang.annotation.Annotation,但是注解不允许显示继承于其他的接口 有个问题，Java中所有类都隐式继承与Object类这个说法正确吗？ 如何访问注解通过Java的反射机制读取注解的信息若要通过反射来读取注解信息，那么被定义的注解的保留期限必须是RententionPolicy.RUNTIME,只有该策略下的注解信息会被保留在目标类代码的字节码中，并且当类加载器加载字节码时会将注解信息加载到JVM中 定义注解12345@Retention(RetentionPolicy.RUNTIME) // 定义@NeedTest注解的保留期限，该注解会保存到目标类的字节码中，并且会被类加载器加载到JVM中@Target(ElementType.METHOD) // 定义@NeedTest注解的应用目标，这是一个方法级别的注解public @interface NeedTest &#123; boolean value() default true; // 单个成员，成员名必须是value(), 默认值是true&#125; 使用注解12345678910111213141516public class MyService &#123; public void saySomething()&#123; System.out.println("say something"); &#125; @NeedTest(true) // 成员名value()设置为true public void sayHello(String name)&#123; System.out.println("hello "+ name); &#125; @NeedTest(false) // 成员名value()设置为false public void sayHi(String name)&#123; System.out.println("hi " + name); &#125;&#125; 访问注解123456789101112131415161718@Testpublic void testCustomAnnotation() &#123; Class clazz = MyService.class; Method[] methods = clazz.getDeclaredMethods(); if (methods.length == 0)&#123; System.out.println("method " + clazz.getName() + " has no declared method"); &#125;else &#123; for (Method method : methods)&#123; NeedTest annotation = method.getAnnotation(NeedTest.class); // 所有自定义的注解都隐式继承自java.lang.annotation.Annotation接口，但是不允许显示继承其他接口 if (annotation == null)&#123; System.out.println("method" + method.getName() + " has not annotated @NeedTest"); &#125;else &#123; boolean value = annotation.value(); System.out.println(method.getName() + " has annotated @NeedTest and value = " + value); &#125; &#125; &#125;&#125; 参考链接《精通Spring4.x——企业应用开发实践》 第8章 基于@AspectJ和Schema的AOP 8.2 Java5.0注解知识快速进阶]]></content>
      <categories>
        <category>JDK</category>
        <category>Annotation</category>
      </categories>
      <tags>
        <tag>Annotation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[说说反射的用途及实现]]></title>
    <url>%2F2018%2F05%2F10%2F%E8%AF%B4%E8%AF%B4%E5%8F%8D%E5%B0%84%E7%9A%84%E7%94%A8%E9%80%94%E5%8F%8A%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[抽象类和接口有什么区别]]></title>
    <url>%2F2018%2F05%2F10%2F%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[重载和重写的区别]]></title>
    <url>%2F2018%2F05%2F10%2F%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[String、StringBuilder、StringBuffer]]></title>
    <url>%2F2018%2F05%2F10%2FString%E3%80%81StringBuilder%E3%80%81StringBuffer%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[包装类，装箱和拆箱]]></title>
    <url>%2F2018%2F05%2F10%2F%E5%8C%85%E8%A3%85%E7%B1%BB%EF%BC%8C%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[int 和 Integer 有什么区别，Integer的值缓存范围]]></title>
    <url>%2F2018%2F05%2F10%2Fint-%E5%92%8C-Integer-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%8CInteger%E7%9A%84%E5%80%BC%E7%BC%93%E5%AD%98%E8%8C%83%E5%9B%B4%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[请写出5种常见到的runtime exception]]></title>
    <url>%2F2018%2F05%2F10%2F%E8%AF%B7%E5%86%99%E5%87%BA5%E7%A7%8D%E5%B8%B8%E8%A7%81%E5%88%B0%E7%9A%84runtime-exception%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Exception、Error、运行时异常与一般异常有何异同]]></title>
    <url>%2F2018%2F05%2F10%2FException%E3%80%81Error%E3%80%81%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8%E4%B8%8E%E4%B8%80%E8%88%AC%E5%BC%82%E5%B8%B8%E6%9C%89%E4%BD%95%E5%BC%82%E5%90%8C%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[final, finally, finalize 的区别]]></title>
    <url>%2F2018%2F05%2F10%2Ffinal-finally-finalize-%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[WebApplicationContext与ServletContext的相关问题]]></title>
    <url>%2F2018%2F05%2F10%2FWebApplicationContext%E4%B8%8EServletContext%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[概述ContextLoaderListener类图 参考链接]]></content>
      <categories>
        <category>Spring</category>
        <category>WebMVC</category>
      </categories>
      <tags>
        <tag>ApplicationContext</tag>
        <tag>ServletContext</tag>
        <tag>Spring</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis缓存的相关问题]]></title>
    <url>%2F2018%2F05%2F10%2FMyBatis%E7%BC%93%E5%AD%98%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[概述 MyBatis一级缓存和二级缓存的实现原理是什么？ MyBatis二级缓存的实现方式有哪些，默认使用什么方式？ MyBatis缓存最佳实践 实现原理一级缓存是sqlsession级别，MyBatis默认开启一级缓存， 二级缓存是Mapper级别，默认是关闭的。 参考链接https://www.cnblogs.com/fqwsndc1314-5207788/p/7594924.html]]></content>
      <categories>
        <category>Java</category>
        <category>MyBatis</category>
        <category>Cache</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Mybatis</tag>
        <tag>Cache</tag>
        <tag>缓存</tag>
        <tag>一级缓存</tag>
        <tag>二级缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发与多线程]]></title>
    <url>%2F2018%2F05%2F09%2F%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[概述 什么是并发，与并行的区别 为什么要用到并发 并发编程最佳实践 什么是并发，与并行的区别在计算机程序世界中，并发指的是计算机可以执行多个任务的能力；而并行指计算机能同时处理多个任务，它们的最关键点是同时。 为什么要用到并发多核的CPU的背景下，催生了并发编程的趋势，并发编程的形式可以将多核CPU的计算能力发挥到极致，提高程序的性能 并发编程最佳实践先说说并发编程哪些缺点，或者说要注意些什么： 上下文切换时间片是CPU分配给各个线程的时间，因为时间非常短，所以CPU不断通过切换线程，让我们觉得多个线程是同时执行的，时间片一般是几十毫秒。 如果多个线程在并发执行任务的时候频繁地切换上下文，将无法发挥并发编程的优势，因为上下文的切换要保存当前状态，以便能够恢复先前状态，而上线文切换又非常损耗性能。 线程安全 多线程编程中最难以把握的就是临界区线程安全问题，稍微不注意就会出现死锁的情况，一旦产生死锁就会造成系统功能不可用。 如何保证线程安全 如何正确理解由于JMM内存模型在原子性，有序性，可见性带来的问题 数据脏读 DCL双重检车加锁 DCL双重检车加锁DCL双重检车加锁的真正问题在于：当没有同步的情况下读取一个共享对象时，读到的可能是一个尚未创建完成的对象，可能是一个失效的值。为什么要第二次判断呢？原因是当多个线程都经过了第一次判空之后，如果锁内不判空，就会导致实例被重复创建 对于可变对象必须通过安全的方式来发布，这通常意味着在发布和使用该对象时都必须使用同步，我们可以使用一下的方式来安全地发布对象： 参考链接 https://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&amp;mid=2247485326&amp;idx=1&amp;sn=62ef70c9baac6ccaec385b519cdbdb6c&amp;chksm=ebd638a2dca1b1b4bc38d6add52c26d0c8d96021fcf0eae18a911abbb32c6b2d33b2af177d60&amp;mpshare=1&amp;scene=23&amp;srcid=0509oLVaS1l1ByXNHBg7zUI1%23rd 《Java并发编程实战》3.5.3，16.2.4]]></content>
      <categories>
        <category>JDK</category>
        <category>Concurrent</category>
      </categories>
      <tags>
        <tag>Thread</tag>
        <tag>Concurrent</tag>
        <tag>并发</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java线程池相关问题]]></title>
    <url>%2F2018%2F05%2F08%2FJava%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[概述在任务队列长度有限的情况下就会出现新任务的拒绝处理问题，需要有一种策略来处理应该加入任务队列却因为队列已满无法加入的情况；在线程池关闭的时候也需要对任务加入队列操作进行额外的协调处理 Java线程池任务拒绝策略RejectedExecutionHandler提供了四种方式来处理任务拒绝策略 直接丢弃（DiscardPolicy） 丢弃队列中最老的任务(DiscardOldestPolicy)。 抛异常(AbortPolicy) 将任务分给调用线程来执行(CallerRunsPolicy)。 ExecutorService类图 ThreadPoolExecutor类图 参考链接https://blog.csdn.net/u010412719/article/details/52132613 http://www.importnew.com/19011.html http://www.importnew.com/27305.html https://www.cnblogs.com/dolphin0520/p/3949310.html]]></content>
      <categories>
        <category>JDK</category>
        <category>ThreadPool</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Thread</tag>
        <tag>ThreadPool</tag>
        <tag>Executer</tag>
        <tag>ExecuterService</tag>
        <tag>BlockingQueue</tag>
        <tag>任务拒绝策略</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ActiveMQ相关问题]]></title>
    <url>%2F2018%2F05%2F08%2FActiveMQ%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[概述 消息传递方式P2P点对点 消息可以被同步或异步的发送和接收，每个消息只会给一个 Consumer 传送一次 多个 Consumer 可以注册到同一个 queue 上，但一个消息只能被一个 Consumer 所接收 P2P模式下，queue的大小默认是多少，可以调整吗？Pub/Sub 发布/订阅 除非显式指定，否则 topic 不会为订阅者保留消息 持久化订阅者重新连接 (对于Topic而言，一条消息只有所有的订阅者都消费才会被删除 ActiveMQ优化GitHub地址源码地址 参考链接https://mp.weixin.qq.com/s?__biz=MzA3ODQ0Mzg2OA==&amp;mid=2649047618&amp;idx=1&amp;sn=f14a50c42f07e263a4e8c3eef0543e6b&amp;chksm=87534671b024cf67dcea059f2fddbe408c1cf56b1687e18c3f2f9aec15a34284c2d38de67c8d&amp;mpshare=1&amp;scene=23&amp;srcid=0508MUi5BoS2wAQvewIzzOdp%23rd https://blog.csdn.net/java20150326/article/details/72084657https://blog.csdn.net/u012758088/article/details/78046108http://shift-alt-ctrl.iteye.com/blog/2061859]]></content>
      <categories>
        <category>JMS</category>
      </categories>
      <tags>
        <tag>JMS</tag>
        <tag>ActiveMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[八皇后问题]]></title>
    <url>%2F2018%2F05%2F08%2F%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[概述 什么是八皇后问题？ 八皇后问题的难点是什么？ 如何实现？-源码 背景如何能够在8×8的国际象棋棋盘上放置八个皇后，使得任何一个皇后都无法直接吃掉其他的皇后？为了达到此目的，任两个皇后都不能处于同一条横行、纵行或斜线上 难点有哪些递归回溯法 所谓递归回溯，本质上是一种枚举法。这种方法从棋盘的第一行开始尝试摆放第一个皇后，摆放成功后，递归一层，再遵循规则在棋盘第二行来摆放第二个皇后。如果当前位置无法摆放，则向右移动一格再次尝试，如果摆放成功，则继续递归一层，摆放第三个皇后…… 12345678910111213141516private static boolean settleQueen(int r)&#123; if (r == row)&#123; // 为最后一行设置Queen时返回true，因为这行的结果不会影响其他的行 return true; &#125; for (int index = 0; index &lt; col; index++)&#123; // 从第一列遍历到最后一列 // 当前行元素都清零,为回溯做铺垫 clearRow(r); if (check(r, index))&#123; chess[r][index] = 1; if (settleQueen(r + 1))&#123;// 递归,如果返回false则回溯 return true; &#125; &#125; &#125; return false;&#125; 如何判断某个格子的斜线上是否已经存在Queen 同一条斜线上的元素的索引的和相等,或者同一条斜线上的元素的索引的差相等 1234567891011121314151617181920private static boolean check(int i, int j)&#123; int sum = i + j; // 同一条斜线上的元素的索引的和相等 int sub = i - j; // 或者 同一条斜线上的元素的索引的差相等 for (int m = sum &gt;= row ? row - 1 : sum; m &gt;= 0 &amp;&amp; sum - m &lt; col; m--)&#123; if (chess[m][sum - m] == 1)&#123; return false; &#125; &#125; for (int m = sub &lt;= 0 ? 0 : sub; m &lt; row &amp;&amp; m - sub &lt; row; m++)&#123; if (chess[m][m - sub] == 1)&#123; return false; &#125; &#125; for (int m = 0; m &lt; row; m++)&#123; if (chess[m][j] == 1)&#123; return false; &#125; &#125; return true;&#125; GitHub地址源码地址 参考链接https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;mid=2653193309&amp;idx=1&amp;sn=dd68a60873bb360e02afde21acde7d3f&amp;chksm=8c99f687bbee7f91049c253dd3193c9a60d6d98cd315b0140a8635b2d34933b54a19127921a9&amp;mpshare=1&amp;scene=23&amp;srcid=0508U4Oiadttnnqx96Es30nZ%23rd https://blog.csdn.net/friendan/article/details/8809089]]></content>
  </entry>
  <entry>
    <title><![CDATA[RPC与RMI的区别]]></title>
    <url>%2F2018%2F05%2F07%2FRPC%E4%B8%8ERMI%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[概述 使用JDK原生RMI框架 参考连接https://blog.csdn.net/xiaominthere/article/details/46501505https://blog.csdn.net/shan9liang/article/details/8995023]]></content>
      <categories>
        <category>RPC</category>
        <category>RMI</category>
      </categories>
      <tags>
        <tag>RPC</tag>
        <tag>RMI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dubbo框架常见问题]]></title>
    <url>%2F2018%2F05%2F07%2FDubbo%E6%A1%86%E6%9E%B6%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[概述 常见问题默认使用的是什么通信框架，还有别的选择吗?答： Dubbo默认使用Dubbo协议，而Dubbo协议使用基于mina + hessian的tbremoting交互；除此之外Dubbo还可以选择: 采用JDK标准的java.rmi.*实现的rmi协议，它采用阻塞式短连接和JDK标准序列化方式 hessian协议，底层采用HTTP通信，采用Servlet暴露服务，默认内嵌Jetty作为服务器实现 基于HTTP表单的远程调用协议，采用Spring的HttpInvoker实现 基于webservice的远程调用协议，基于Apache CXF的fronted-simple和transports-http、基于原生thrift协议的扩展，比如协议头添加额外字段 基于memcached实现的RPC协议 基于Redis实现的RPC协议 参考链接Dubbo用户手册（中文）9 协议参考手册 ALIBABA DUBBO框架同步调用原理分析www.blogjava.net/xiaomage234/archive/2014/05/09/413465.html]]></content>
      <categories>
        <category>Dubbo</category>
      </categories>
      <tags>
        <tag>RPC</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于ArrayList、LinkedList序列化问题]]></title>
    <url>%2F2018%2F05%2F04%2F%E5%85%B3%E4%BA%8EArrayList%E3%80%81LinkedList%E5%BA%8F%E5%88%97%E5%8C%96%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[在序列化过程中，虚拟机会试图调用对象类里的 writeObject 和 readObject 方法，进行用户自定义的序列化和反序列化，如果没有这样的方法，则默认调用&gt; 是 ObjectOutputStream 的 defaultWriteObject 方法以及 ObjectInputStream 的 defaultReadObject 方法。用户自定义的 writeObject &gt; &gt; 和 readObject 方法可以允许用户控制序列化的过程，比如可以在序列化的过程中动态改变序列化的数值。基于这个原理，可以在实际应用中得到使用，用于敏感&gt; 字段的加密工作，清单 3 展示了这个过程。 参考链接https://www.ibm.com/developerworks/cn/java/j-lo-serial/index.htmlhttps://blog.csdn.net/qfycc92/article/details/45370011https://blog.csdn.net/u014634338/article/details/78165127]]></content>
      <categories>
        <category>JDK</category>
        <category>Collections</category>
        <category>List</category>
      </categories>
      <tags>
        <tag>List</tag>
        <tag>ArrayList</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多道程序设计、进程、线程]]></title>
    <url>%2F2018%2F05%2F03%2F%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%81%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[概要 什么是多道程序设计？ 什么是进程？ 什么是线程？ 为什么要使用多线程而不是多进程？ text ../hello-world 参考链接]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown+gravizo画UML类图]]></title>
    <url>%2F2018%2F04%2F28%2Fmarkdown-gravizo%E7%94%BBUML%E7%B1%BB%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[1. 将请求参数进行url编码2. 不需要编码使用&lt;&gt;将网址括起来 本文不对plantUML的语法进行解释，直接戳。 对url进行编码需要编码的字符如下123abstract class AbstractList;interface List;List &lt;|.. AbstractList; 使用在线编码网站提供的服务，直接戳 编码后的代码如下：1abstract%20class%20AbstractList%3B%0Ainterface%20List%3B%0AList%20%3C%7C..%20AbstractList%3B 请求的url为：1http://g.gravizo.com/svg?abstract%20class%20AbstractList%3B%0Ainterface%20List%3B%0AList%20%3C%7C..%20AbstractList%3B 在markdown文件中使用：1![示例1](http://g.gravizo.com/svg?abstract%20class%20AbstractList%3B%0Ainterface%20List%3B%0AList%20%3C%7C..%20AbstractList%3B) 结果如下： 使用python的库urllib进行编码 打开终端 输入python,显示结果如下： 12345$ pythonPython 2.7.10 (default, Jul 14 2015, 19:46:27)[GCC 4.2.1 Compatible Apple LLVM 6.0 (clang-600.0.39)] on darwinType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; 引入urllib库:import urllib 为变量raw赋值：raw = ‘’’abstract class AbstractList;interface List;List &lt;|.. AbstractList;’’’ 使用urllib的quote()方法:urllib.quote(raw)，将得到如下的结果:123456789&gt;&gt;&gt; import urllib&gt;&gt;&gt; raw = &apos;&apos;&apos;... abstract class AbstractList;... interface List;... List &lt;|.. AbstractList;... &apos;&apos;&apos;&gt;&gt;&gt; urllib.quote(raw)&apos;%0Aabstract%20class%20AbstractList%3B%0Ainterface%20List%3B%0AList%20%3C%7C..%20AbstractList%3B%0A&apos;&gt;&gt;&gt; 得到结果与gravizo的网址组合在一起，如下：1http://g.gravizo.com/svg?%0Aabstract%20class%20AbstractList%3B%0Ainterface%20List%3B%0AList%20%3C%7C..%20AbstractList%3B%0A 在markdown文件中使用：1![示例2](http://g.gravizo.com/svg?%0Aabstract%20class%20AbstractList%3B%0Ainterface%20List%3B%0AList%20%3C%7C..%20AbstractList%3B%0A) 结果如下： 不需要编码使用&lt;&gt;将网址括起来沿用上面的字符如下123abstract class AbstractList;interface List;List &lt;|.. AbstractList; 在markdown中使用1![示例3](&lt;http://g.gravizo.com/g?abstract class AbstractList;interface List;List &lt;|.. AbstractList;&gt;) 注意&lt;&gt;中的url连接不能有回车符号，但可以有空格 UML类图各线条怎么表示继承1234child --|&gt; parent![继承](http://g.gravizo.com/svg?Child --|&gt; Parent;)or ![继承](http://g.gravizo.com/svg?Parent &lt;|-- Child;) or 实现接口1234ServiceImpl ..|&gt; Service![实现接口](http://g.gravizo.com/svg?ServiceImpl ..|&gt; interface Service;)or![实现接口](http://g.gravizo.com/svg?nterface Service &lt;|.. ServiceImpl;) or 关联12Class09 -- Class10![关联](http://g.gravizo.com/svg?Class09 -- Class10) 依赖12Class13 --&gt; Class14![依赖](http://g.gravizo.com/svg?Class13 --&gt; Class14) 组合1234567Person1 --* Hand1orPerson --* Hand : 2 contains 1 &lt;eg: ![组合](http://g.gravizo.com/svg?Person *-- Hand : 1 contains 2 &gt;;Person1 --* Hand1)or![组合](http://g.gravizo.com/svg?Person --* Hand : 2 contains 1 &lt;;Person1 --* Hand1) or 聚合1234567Wheel : 1 have 4 &gt;orCar1 "1" o-- "4" Wheel1eg: ![聚合](http://g.gravizo.com/svg?Car o-- Wheel : 1 have 4 &gt;;Car o-- Wheel)or![聚合](http://g.gravizo.com/svg?Wheel1 --o Car1 : 4 have 1 &lt;;Wheel1 --o Car1) or 参考链接 Markdown 绘制 UML 图 -- PlantUML + Gravizoblog.csdn.net/heqiangflytosky/article/details/77050849 Markdown 绘制 UML 图 -- PlantUML + Gravizowww.heqiangfly.com/2017/07/08/development-tool-markdown-plant-uml URL Decoder/Encodermeyerweb.com/eric/tools/dencoder plantUML online editorwww.plantuml.com/plantuml/uml/SoWkIImgAStDuGh9BCb9LL1wldlviyxzJritFz-y--diVKfSReab6Qb52ZOrkheAmVbvN0wfUIb0zG00 https://www.ibm.com/support/knowledgecenter/zh/SS4JE2_7.5.5/com.ibm.xtools.modeler.doc/topics/cassn.html?pos=2]]></content>
      <categories>
        <category>Markdown</category>
        <category>画图</category>
        <category>UML类图</category>
      </categories>
      <tags>
        <tag>UML</tag>
        <tag>类图</tag>
        <tag>Markdown</tag>
        <tag>plantUML</tag>
        <tag>gravizo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinkedList]]></title>
    <url>%2F2018%2F04%2F28%2FLinkedList%2F</url>
    <content type="text"><![CDATA[1. java中LinkedList是单链表实现还是双链表实现？2. java中LinkedList节点元素的结构是怎样的？3. java中LinkedList的get（int index）方法是如何实现的？以及add（）方法是如何实现的？ java中LinkedList是单链表实现还是双链表实现？java中LinkedList节点元素的结构是怎样的？1234567891011private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; 以上diamante截取自jdk8的LinkedList类，它是LinkedList类中节点元素，可以看出java中LinkedList是双链表实现的，因为静态内部类Node有两个指针，一个指向父节点，一个指向子节点（问题1，2自解） java中LinkedList的get（int index）方法是如何实现的？以及add（）方法是如何实现的？123456789101112131415161718192021222324252627282930313233343536373839404142public boolean add(E e) &#123; linkLast(e); return true;&#125; public void add(int index, E element) &#123; checkPositionIndex(index); if (index == size) linkLast(element); else linkBefore(element, node(index));&#125;void linkBefore(E e, Node&lt;E&gt; succ) &#123; // assert succ != null; final Node&lt;E&gt; pred = succ.prev; final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); succ.prev = newNode; if (pred == null) first = newNode; else pred.next = newNode; size++; modCount++;&#125;Node&lt;E&gt; node(int index) &#123; // assert isElementIndex(index); if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125; 从上面这段代码可以看出，当调用LinkedList的add(E)方法插入元素时，默认插入链表的末尾；当调用LinkedList的add(int, E)方法在指定位置插入元素时，通过node(int index)方法遍历链表，找到该索引位置的元素节点（在查找时用到了折半的思想，当索引小于size的一半时从前向后遍历，否则从后向前遍历），然后做节点的插入 1234public E get(int index) &#123; checkElementIndex(index); return node(index).item;&#125; 从上面这段代码可以看出，java中LinkedList的get(int index)方法查询元素时，会通过node(int index)方法遍历链表找到对应位置的元素节点（上一段代码有给出node方法的源码），并返回其值 Java中LinkedList的UML类图]]></content>
      <categories>
        <category>JDK</category>
        <category>Collections</category>
        <category>List</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JDK</tag>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[macOS系统使用hexo创建文章时自动用喜爱的编辑器打开]]></title>
    <url>%2F2018%2F04%2F26%2FmacOS%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8hexo%E5%88%9B%E5%BB%BA%E6%96%87%E7%AB%A0%E6%97%B6%E8%87%AA%E5%8A%A8%E7%94%A8%E5%96%9C%E7%88%B1%E7%9A%84%E7%BC%96%E8%BE%91%E5%99%A8%E6%89%93%E5%BC%80%2F</url>
    <content type="text"><![CDATA[在博客根目录下找到scripts文件夹，如果没有就创建该文件夹，在scripts文件夹中创建open.js,内容如下：12345var spawn = require(&apos;child_process&apos;).spawn;hexo.on(&apos;new&apos;, function(data)&#123; spawn(&apos;open&apos;, [&apos;-a&apos;, &apos;/Applications/Visual\ Studio\ Code.app&apos;, data.path]);&#125;); 当我们在博客根目录下使用终端新建文件时会使用VScode编辑器打开该文章，可以方便地进行编辑1hexo new article_name 参考链接 hexo new 后同步打开文章编辑器www.jianshu.com/p/4487d767e651 Nodejs进阶：如何玩转子进程（child_process）www.cnblogs.com/chyingp/p/node-learning-guide-child_process.html]]></content>
      <tags>
        <tag>Mac</tag>
        <tag>Hexo</tag>
        <tag>VScode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hashMap]]></title>
    <url>%2F2018%2F04%2F26%2FhashMap%2F</url>
    <content type="text"><![CDATA[概要关于HashMap的几个基本问题： hashMap的工作原理？ hashMap可以接收key为null的键值对吗？hashTable可以接收key为null的键值对吗？ hashMap的负载因子是做什么的？ hashMap在JDK7和JDK8中的区别是什么？ 简述HashMap的put方法的过程 简述HashMap的get方法的过程 什么时候会使用HashMap？他有什么特点？ 你知道HashMap的工作原理吗？ 你知道get和put的原理吗？equals()和hashCode()的都有什么作用？ 你知道hash的实现吗？为什么要这样实现？ 如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？ 常见问题 什么时候会使用HashMap？他有什么特点？需要保存key-value形式的键值对时，需要要使用HashMap，或者我们希望通过key快速查询到它所对应的value时，就会使用HashMapHashMap的特点：将key散列到表中，使用key的散列值查询元素，理想情况下，查询元素的时间复杂度是常数级别；通常情况下，保存key、value时，如果需要保存的key已经存在于散列表中，后面的值会覆盖前面的值；HashMap的键和值都允许是null，HashMap保存元素的最大值是Integer.MAX_VALUE； 在JDK7和JDK8中最大的区别就是JDK8优化了当发生严重hash冲突时的查询优化，当满足一定的条件，使用红黑树代替链表来存储数据 HashMap的工作原理HashMap的工作原理就是通过计算key的hash值，将key、value保存到对应的hash桶中，如果发生hash冲突，就用链表的方式将这些key、value连接起来；访问某个key、value时，同样的方式，先计算key的hash值，从而定位key、value所在的hash桶 put方法的过程 判断数据是否为空，为空就resize，resize方法中包含了HashMap的初始化代码 通过hash方法计算key的hash值，确定桶的位置，如果索引位置的桶内元素为空，就将数据保存到该位置 如果桶内已经有元素了，判断该元素的key的hash是否与被插入的key的hash是否相等，以及key是否相等，如果相等，则替换值 如果不相等，再判断该节点是否是红黑树的节点，如果是，则调用添加树节点的方法插入数据 如果不是红黑树节点，则循环遍历链表，找到与key相等的节点就覆盖它的值，反之，则新增一个节点，链在链表的后面 在判断链表长度是否超过TREEFIY_THRESHOLD的值，如果超过了，就将链表树形化， 最后判断HashMap的容量是否超过了threshold, 如果超过了，就扩容 get方法的过程 如果HashMap中的table为空，或者key经过hash方法计算后的hash值所映射的桶为空，就返回空 反之，则判断桶里的元素的key的hash值、key值是否相等，如果相等，直接返回该元素 如果不相等，则判断该元素的下一个节点是否为空，如果为空，则返回空，如果不为空 则判断桶中的元素是否是TreeNode，如果是，则调用获取树节点的方法返回数据 反之，则遍历链表 hashMap的定义hashMap是一种散列表，根据key的hash值被散列到表的不同位置，如果发生hash冲突，冲突的元素会以链表的形式存储 put(K k, V v)查看put方法的源码，可以看出，hashMap是允许key为null的123public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125; 查看hash方法的源码，我们知道如果key为null，那么hash值是0，否则会调用key的hashCode方法计算key的hash值（这也是为什么要重写key的hashCode方法的原因），并将hash值与它的高16位进行异或操作1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; 当调用hashMap的put方法保存键值对时，通过hash方法重新计算key的hash值，如果hash值散列到散列表的索引处没有没有发生hash冲突，则将键值对保存即可,下面是putVal方法的代码片段12if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); 如果发生hash冲突，判断hash值所对应的散列表位置的元素是不是TreeNode（jdk版本1.8），如果是，直接调用添加一个TreeNode节点，源码片段如下12else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); 如果fa’shegn不是TreeNode， 参考资料Java中HashMap的UML类图]]></content>
      <categories>
        <category>JDK</category>
        <category>Collections</category>
        <category>Map</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JDK</tag>
        <tag>Map</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F08%2F27%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. blog框架hexo,主题框架NexT Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 标签插件（Tags Plugins)123&#123;% blockquote [author[, source]] [link] [source_link_title] %&#125;content&#123;% endblockquote %&#125; 参考链接https://hexo.io/zh-cn/docs/tag-plugins.html]]></content>
  </entry>
</search>
