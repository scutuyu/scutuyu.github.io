<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Redis集群搭过程</title>
      <link href="/2018/07/23/Redis%E9%9B%86%E7%BE%A4%E6%90%AD%E8%BF%87%E7%A8%8B/"/>
      <url>/2018/07/23/Redis%E9%9B%86%E7%BE%A4%E6%90%AD%E8%BF%87%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>你会知道如何安装redis, ruby, rubygems<br>如何解决gem安装依赖慢甚至失败的问题<br>如何用gem安装redis<br><a id="more"></a></p><h1 id="Reids集群搭建过程"><a href="#Reids集群搭建过程" class="headerlink" title="Reids集群搭建过程"></a>Reids集群搭建过程</h1><ul><li><code>cat /etc/*-release</code><br>CentOS Linux release 7.3.1611 (Core)</li><li><code>wget http://download.redis.io/releases/redis-3.2.9.tar.gz</code><br>下载redis的源码包</li><li><code>tar -xzvf redis-3.2.9.tar.gz</code><br>解压源码包</li><li><code>cd redis-3.2.9 &amp;&amp; make &amp;&amp; make install</code><br>编译，然后安装</li><li><code>redis-server -v</code><br>Redis server v=3.2.9 sha=00000000:0 malloc=jemalloc-4.0.3 bits=64 build=5eeb62d2aadbc6d5</li><li><code>yum install -y ruby rubygems</code><br>安装ruby,gem</li><li><code>gem sources --add https://gems.ruby-china.org/ --remove https://rubygems.org/</code><br>修改RubyGems 镜像</li><li><code>gem update --system</code><br>升级gem</li><li><code>gem install reids</code><br>安装gem-redis依赖</li><li><p><code>vim start.sh</code><br>启动脚本,内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##! /bin/bash</span></span><br><span class="line"></span><br><span class="line">redis-server ./7000/redis.conf</span><br><span class="line">redis-server ./7001/redis.conf</span><br><span class="line">redis-server ./7002/redis.conf</span><br><span class="line">redis-server ./7003/redis.conf</span><br><span class="line">redis-server ./7004/redis.conf</span><br><span class="line">redis-server ./7005/redis.conf</span><br></pre></td></tr></table></figure></li><li><p><code>vim ./700x/redis.conf</code><br>修改reids配置文件，修改的内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 端口</span></span><br><span class="line">port 7000</span><br><span class="line"><span class="comment"># 后台运行</span></span><br><span class="line">daemonize yes</span><br><span class="line"><span class="comment"># pid文件路径</span></span><br><span class="line">pidfile /var/run/redis_7000.pid</span><br><span class="line"><span class="comment"># log文件路径</span></span><br><span class="line">logfile <span class="string">"nodes-7000.log"</span></span><br><span class="line"><span class="comment"># dbfilename</span></span><br><span class="line">dbfilename dump-7000.rdb</span><br><span class="line"><span class="comment"># db文件路径</span></span><br><span class="line">dir /usr/<span class="built_in">local</span>/share/applications/redis/dbs</span><br><span class="line"><span class="comment"># 开启AOF</span></span><br><span class="line">appendonly yes</span><br><span class="line"><span class="comment"># 配置AOF文件名</span></span><br><span class="line">appendfilename <span class="string">"appendonly-7000.aof"</span></span><br><span class="line"><span class="comment"># 开启集群模式</span></span><br><span class="line">cluster-enabled yes</span><br><span class="line"><span class="comment"># 集群配置文件</span></span><br><span class="line">cluster-config-file nodes-7000.conf</span><br><span class="line"><span class="comment"># 集群间节点通信超时</span></span><br><span class="line">cluster-node-timeout 5000</span><br></pre></td></tr></table></figure></li><li><p><code>chmod +x start.sh</code><br>使shell脚本可以运行</p></li><li><code>./start.sh</code><br>运行start.sh脚本，启动redis实例</li><li><code>ps -ef | grep redis | grep -v grep</code><br>查看redis实例运行情况</li><li><code>cp ./redis-3.2.9/src/redis-trib.rb /usr/local/bin/</code><br>将redis-trib.rb复制到PATH路径上，可以在终端任何位置都可以执行redis-trib命令</li><li><p><code>vim cluster.sh</code><br>集群创建脚本，内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"></span><br><span class="line">redis-trib create --replicas 1 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005</span><br></pre></td></tr></table></figure></li><li><p><code>chmod +x cluster.sh</code><br>使shell脚本可以运行</p></li><li><code>./cluster.sh</code><br>运行cluster.sh脚本，创建redis集群</li><li><code>redis-trib check 127.0.0.1:7000</code><br>查看集群状态,<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:7000)</span><br><span class="line">M: 0cd3b76dee6ccc78cfe37421386a55c752ef60a5 127.0.0.1:7000</span><br><span class="line">   slots:0-5460 (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 83e2fefef3c4ed18be37f406d8b28ec3ac6ad14f 127.0.0.1:7004</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 85903c099043fd29bb70d1b7212358d7e1317e06</span><br><span class="line">S: d7191c35b23f9ab381e1a26443ef19c0ccf4fed7 127.0.0.1:7003</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 0cd3b76dee6ccc78cfe37421386a55c752ef60a5</span><br><span class="line">M: e9df2796f7aaf6ccb8f1c0737b9a23cd0d1ccddf 127.0.0.1:7002</span><br><span class="line">   slots:10923-16383 (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: 85903c099043fd29bb70d1b7212358d7e1317e06 127.0.0.1:7001</span><br><span class="line">   slots:5461-10922 (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: c134c73ec11db000bce895df5c133e283969a6d4 127.0.0.1:7005</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates e9df2796f7aaf6ccb8f1c0737b9a23cd0d1ccddf</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check <span class="keyword">for</span> open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure></li></ul><h1 id="Redis客户端的使用"><a href="#Redis客户端的使用" class="headerlink" title="Redis客户端的使用"></a>Redis客户端的使用</h1><h2 id="redis-cli"><a href="#redis-cli" class="headerlink" title="redis-cli"></a><code>redis-cli</code></h2><p>直接在终端输入redis-cli默认连接的是127.0.0.1:6379,如果在本地6379端口没有启动redis实例，将会报错<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@tuyu redis]<span class="comment"># redis-cli</span></span><br><span class="line">Could not connect to Redis at 127.0.0.1:6379: Connection refused</span><br><span class="line">Could not connect to Redis at 127.0.0.1:6379: Connection refused</span><br><span class="line">not connected&gt;</span><br></pre></td></tr></table></figure></p><h2 id="redis-cli-p-7000"><a href="#redis-cli-p-7000" class="headerlink" title="redis-cli -p 7000"></a><code>redis-cli -p 7000</code></h2><p>前提：<br>本地在7000-7005端口分别启了一个redis实例，并将这些redis实例组成了一个redis集群<br>连接本地7000端口的redis实例<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@tuyu redis]<span class="comment"># redis-cli -p 7000</span></span><br><span class="line">127.0.0.1:7000&gt;</span><br></pre></td></tr></table></figure></p><p>以集群的方式连接redis服务器<br><code>redis-cli -c -h 127.0.0.1 -p 7001</code></p><p>redis服务器的模式有三种</p><ul><li>主从模式</li><li>哨兵模式</li><li>集群模式</li></ul><p>主从模式，常见的有一主一从，一主多从<br>主从模式的好处是：数据备份，读写分离，解决了流量瓶颈问题<br>主从模式的缺点是：不能解决故障迁移问题</p><p>哨兵模式，在主从模式的基础上，额外起技术哥哨兵进程，让哨兵进程监视主节点，当主节点宕机后，通过投票机制选举一个从节点替代宕机的主节点，并让其他的从节点作为新的主节点的从节点<br>哨兵模式的好处是：解决了主从模式没有解决的故障自动迁移的问题<br>哨兵模式的缺点是：从节点下线了，不会对其进行故障迁移的</p><p>集群模式，将key映射到16384个hash槽里，集群中每个节点都分配部分hash槽，当客户端连接集群中的某个节点，并执行操作时，通过一致的hash算法，计算书key所对应的hash并对16384取模，再用得到的结果去映射到具体的集群节点，如果不是当前节点，操作将被重定向到具体的节点，redis集群是去中心化的，所有节点都是平等的，集群间通信使用goossip协议，为解决集群中某个节点下线后，对应的hash槽不可用的情况，可以为集群中的所有节点都设置一至多个从节点，当主节点下线后，从节点替代主节点<br>集群模式的好处是：解决了单机内存限制，解决了流量瓶颈问题<br>集群模式的缺点是：当某个节点与它的所有从节点都下线后，它所处理的hash槽都不可用了，需要人工介入，从新分配hash槽</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.jianshu.com/p/c869feb5581d" target="_blank" rel="noopener">https://www.jianshu.com/p/c869feb5581d</a></p><p><a href="https://ruby.taobao.org/" target="_blank" rel="noopener">https://ruby.taobao.org/</a></p><p><a href="http://weizijun.cn/2016/01/08/redis%20cluster%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7redis-trib-rb%E8%AF%A6%E8%A7%A3/" target="_blank" rel="noopener">http://weizijun.cn/2016/01/08/redis%20cluster%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7redis-trib-rb%E8%AF%A6%E8%A7%A3/</a></p>]]></content>
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> Redis集群 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>io</title>
      <link href="/2018/07/11/io/"/>
      <url>/2018/07/11/io/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ol><li>谈谈io与装饰者模式<a id="more"></a></li></ol><h1 id="io与装饰者模式"><a href="#io与装饰者模式" class="headerlink" title="io与装饰者模式"></a>io与装饰者模式</h1><p>首先，装饰者模式中装饰者和被装饰者都会继承同一个Component(抽象类或者接口)，通常情况，装饰者大多会直接继承一个抽象的装饰者Decorator，这个抽象的装饰者直接继承Component，且抽象装饰者中保存了被装饰者的一个引用，装饰者会将客户端所有的请求都应用到被装饰者上，并动态地增强被装饰者的属性或者功能。当然这个抽象的装饰者可以不存在，所有的具体装饰者直接继承Component，但是必须保存被装饰者的一个引用，区分具体被装饰者和具体装饰者的关键点就是看这个类是否有一个Component的一个引用，因为装饰者需要这个引用来动态的将请求应用到具体的被装饰着身上，以达到增强属性和功能的目的。<br>装饰者的模式的优点：</p><ul><li>扩展性好<br>  可以针对Component扩展出很多具体的被装饰者concreteComponent，也可以针对Ddecorator扩展出很多具体的装饰者concreteDecorator</li><li>灵活性好<br>  不同的具体装饰者和不同的具体被装饰者可以灵活组合，以实现丰富的功能</li></ul><p>装饰者模式的缺点：</p><ul><li>程序中会出现很多小类，即各种各样的具体装饰者和具体被装饰者</li></ul><p>在java的io框架中有4个基类，分别是<code>InputStream</code>, <code>OutputStream</code>, <code>Reader</code>, <code>Writer</code>, 它们扮演着Component的角色，所有的被装饰者都会直接继承</p><p>直接继承<code>InputStream</code>的具体被装饰者有哪些？ 比如：<code>FileInputStream</code>, <code>PipedInputStream</code>, <code>ByteArrayInputStream</code>.<br>直接继承<code>OutputStream</code>的具体被装饰者有哪些？ 比如：<code>FileOutputStream</code>, <code>PipedOutputStream</code>, <code>ByteArrayOutputStream</code>.<br>直接继承<code>Reader</code>的具体被装饰者有哪些？ 比如：<code>StringReader</code>, <code>CharArrayReader</code>, <code>PipedReader</code>.<br>直接继承<code>Writer</code>的具体被装饰者有哪些？ 比如：<code>StringWriter</code>, <code>CharArrayWriter</code>, <code>PipedWriter</code>.</p><p>装饰<code>InputStream</code>的具体装饰者（可以是抽象的类，也可以是具体的类）有哪些？ 比如：<br><code>FilterInputStream</code>,<br><code>SequenceInputStream</code>,<br><code>BufferedInputStream</code>和<code>DataInputStream</code>都继承自<code>FilterInputStream</code>,<br><code>ObjectInputStream</code>它内部保存了一个<code>BlockDataInputStream</code>的一个引用，它是一个继承<code>InputStream</code>的私有内部类，这些装饰者都是具体的装饰者，并非抽象类。</p><p>装饰<code>OutputStream</code>的具体装饰者（可以是抽象的类，也可以是具体的类）有哪些？ 比如：<br><code>FilterInputStream</code>,<br><code>BufferedInputStream</code>、<code>DataOutputStream</code>和<code>PrintStream</code>都继承自<code>FilterInputStream</code>,<br><code>ObjectOutputStream</code>它内部保存了一个<code>BlockDataOutputStream</code>的一个引用，它是一个继承<code>OutputStream</code>的私有内部类，这些装饰者都是具体的装饰者，并非抽象类。</p><p>装饰<code>Reader</code>的具体装饰者（可以是抽象的类，也可以是具体的类）有哪些？ 比如：<br><code>FilterReader</code>是一个抽象装饰者,<br><code>BufferedReader</code>是一个具体的装饰者,<br><code>InputStreamReader</code>是一个具体装饰者，它并没有直接保存<code>Reader</code>的引用，但是它保存了一个<code>StreamDecoder</code>的引用，而<code>StreamDecoder</code>是一个具体的被装饰者。</p><p>装饰<code>Writer</code>的具体装饰者（可以是抽象的类，也可以是具体的类）有哪些？ 比如：<br><code>PrintWriter</code>,<br><code>BufferedWriter</code>,<br><code>OutputStreamWriter</code>并没有直接保存<code>Writer</code>的引用，但是它保存了一个<code>StreamEncoder</code>的引用，而<code>StreamEncoder</code>是一个具体的被装饰者。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://zhuanlan.zhihu.com/p/28286559" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/28286559</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>nio</title>
      <link href="/2018/07/02/nio/"/>
      <url>/2018/07/02/nio/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ol><li>Buffer<a id="more"></a></li></ol><h1 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h1><p>何谓Buffer? Buffer 是一个线性的有限长度的特定基本数据的序列。 除了基础数据外，它还包括一些基础操作和属性， 比如capacity, limit 和 position. <a href="http://colobu.com/2014/10/20/java-buffer-basic/" target="_blank" rel="noopener">参考链接</a><br><img src="http://g.gravizo.com/svg?abstract java.nio.Buffer &lt;|-- abstract java.nio.ByteBuffer; abstract java.nio.Buffer &lt;|-- abstract java.nio.CharBuffer; abstract java.nio.Buffer &lt;|-- abstract java.nio.DoubleBuffer; abstract java.nio.Buffer &lt;|-- abstract java.nio.FloatBuffer; abstract java.nio.Buffer &lt;|-- abstract java.nio.LongBuffer; abstract java.nio.Buffer &lt;|-- abstract java.nio.IntBuffer; abstract java.nio.Buffer &lt;|-- abstract java.nio.ShortBuffer;;" alt="buffer"></p><h1 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h1><p>调用 Selector 的静态工厂创建一个选择器</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1>]]></content>
      
      
    </entry>
    
    <entry>
      <title>jvm</title>
      <link href="/2018/06/28/jvm/"/>
      <url>/2018/06/28/jvm/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ol><li>JVM运行时内存区域划分</li><li>内存溢出OOM和堆栈溢出SOE的示例及原因、如何排查与解决</li><li>如何判断对象是否可以回收或存活</li><li>常见的GC回收算法及其含义</li><li>常见的JVM性能监控和故障处理工具类：jps、jstat、jmap、jinfo、jconsole等</li><li>JVM如何设置参数</li><li>JVM性能调优</li><li>类加载器、双亲委派模型、一个类的生命周期、类是如何加载到JVM中的</li><li>类加载的过程：加载、验证、准备、解析、初始化</li><li>强引用、软引用、弱引用、虚引用</li><li>Java内存模型JMM<a id="more"></a><h1 id="JVM运行时内存区域划分"><a href="#JVM运行时内存区域划分" class="headerlink" title="JVM运行时内存区域划分"></a><a href="https://blog.csdn.net/zz110753/article/details/70170339" target="_blank" rel="noopener">JVM运行时内存区域划分</a></h1>主要分为5个部分：</li></ol><ul><li>程序计数器</li><li>虚拟机栈</li><li>本地方法栈</li><li>方法区</li><li>堆</li></ul><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>Java是一门解释型的语言，java文件被javac编译成class的字节码文件，字节码解释器会将编译好的字节码文件解释执行，这也java语言可以很好的实现的跨平台的真正原因，而程序计数器中的值保存的是下一条将要被执行的执行的字节码指令的地址，每条线程都会有一个独立的程序计数器，各线程之间互不影响，独立存储。</p><h2 id="java虚拟机栈"><a href="#java虚拟机栈" class="headerlink" title="java虚拟机栈"></a>java虚拟机栈</h2><p>虚拟机栈描述的是java方法执行的内存模型，方法的执行的同时会创建一个栈祯，用于存储方法中的局部变量表、操作数栈、动态链接、方法的出口等信息，每个方法从调用直到执行完成的过程，就对应着一个栈祯在虚拟机栈中入栈到出栈的过程。</p><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法栈与java虚拟机栈类似，也会抛出OutOfMemoryError,和StackOverflowError<br>在HotSpot虚拟机中，本地方法栈和虚拟机栈合二为一</p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区</p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>java堆是java虚拟机所管理的内存中最大的一块，是所有线程共享的内存区域，主要用来保存对象实例，在虚拟机进程启动是创建，按照分带收集算法来说，java对可以细分为新生代和老年代，还可以细分为Edean空间、From Survivor空间，To Survivor空间，java对可以划分出多个线程私有的分配缓冲区，TLAB，进一步划分的目的是为了更好的内存回收，或者更快的内存分配，java堆可以处于物理上不连续的内存区域，逐流的虚拟机都将java堆实现成可扩展的，当java没有内存完成实例分配，且无法再扩展时，将会抛出OutOfMemoryError</p><h1 id="内存溢出OOM和堆栈溢出SOE的示例及原因、如何排查与解决"><a href="#内存溢出OOM和堆栈溢出SOE的示例及原因、如何排查与解决" class="headerlink" title="内存溢出OOM和堆栈溢出SOE的示例及原因、如何排查与解决"></a>内存溢出OOM和堆栈溢出SOE的示例及原因、如何排查与解决</h1><h2 id="OOM示例"><a href="#OOM示例" class="headerlink" title="OOM示例"></a>OOM示例</h2><p>java堆内存发生OOM<br>原因: 程序中有大量的对象生成，并且这些对象不能被GC回收，当java堆不能为实例分配内存时就会发生内存溢出OOM<br>排查: 在启动参数中加上-XX:+HeapDumpOnOutOfMemoryError，当发生内存溢出时，会dump当时的内存堆转储快照文件<br>解决: 通过分析对转储快照文件，是内存溢出还是内存泄漏，如果是内存泄漏，根据泄漏的对象实例确定对象类型，以及GC roots的引用链，从而确定泄漏的代码；如果是内存溢出，查看java堆参数，是否能调大-Xms和-Xmx的值<br>实验：vm args -Xms10M -Xmx10M -XX:+HeapDumpOnOutOfMemoryError<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        list.add(String.valueOf(i++));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在JDK 1.8下<br>运行结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: GC overhead limit exceeded</span><br><span class="line">Dumping heap to java_pid859.hprof ...</span><br><span class="line">Heap dump file created [12059282 bytes in 0.075 secs]</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: GC overhead limit exceeded</span><br><span class="line">Disconnected from the target VM, address: &apos;127.0.0.1:50160&apos;, transport: &apos;socket&apos;</span><br><span class="line">at java.lang.Integer.toString(Integer.java:403)</span><br><span class="line">at java.lang.String.valueOf(String.java:3087)</span><br><span class="line">at com.tuyu.oom.JavaHeapOOM.main(JavaHeapOOM.java:47)</span><br></pre></td></tr></table></figure></p><p>分析：<a href="https://blog.csdn.net/Sugar_Rainbow/article/details/68150249" target="_blank" rel="noopener">参考链接</a><br>垃圾回收器出现了异常</p><blockquote><p>sun官方说明：并行/并发回收器在GC回收时间过长时会抛出OutOfMemroyError。过长的定义是，超过98%的时间用来做GC并且回收了不到2%的堆内存。用来避免内存过小造成应用不能正常工作。</p></blockquote><h2 id="SOE示例"><a href="#SOE示例" class="headerlink" title="SOE示例"></a>SOE示例</h2><p>java虚拟机栈发生SOE<br>原因：线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError<br>排查：通过错误日志，定位发生SOE的代码<br>解决：发生SOE一般是程序中出现了递归调用，检查代码递归是否写错，如果没有写错能否用尾递归优化代码，或者用迭代的方式替换递归算法，或者适当调整-Xss的大小，增大虚拟机允许的最大栈深度<br>实验：vm args: -Xss160k<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        hello();</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Throwable e)&#123;</span><br><span class="line">        System.out.println(<span class="string">"i = "</span> + i);</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">    i++;</span><br><span class="line">    hello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在JDK 1.8下<br>运行结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = 847</span><br><span class="line">java.lang.StackOverflowError</span><br><span class="line">at com.tuyu.oom.JavaHeapOOM.hello(JavaHeapOOM.java:54)</span><br><span class="line">    ....</span><br></pre></td></tr></table></figure></p><p>分析: 在我的电脑中运行此程序，递归调用了847次，160K的栈容量能够支持的栈的最大深度是847，这个也跟不同的方法有关，不同方法的栈帧大小不一</p><h1 id="如何判断对象是否可以回收或存活"><a href="#如何判断对象是否可以回收或存活" class="headerlink" title="如何判断对象是否可以回收或存活"></a>如何判断对象是否可以回收或存活</h1><h1 id="常见的GC回收算法及其含义"><a href="#常见的GC回收算法及其含义" class="headerlink" title="常见的GC回收算法及其含义"></a>常见的GC回收算法及其含义</h1><h1 id="常见的JVM性能监控和故障处理工具类：jps、jstat、jmap、jinfo、jconsole等"><a href="#常见的JVM性能监控和故障处理工具类：jps、jstat、jmap、jinfo、jconsole等" class="headerlink" title="常见的JVM性能监控和故障处理工具类：jps、jstat、jmap、jinfo、jconsole等"></a>常见的JVM性能监控和故障处理工具类：jps、jstat、jmap、jinfo、jconsole等</h1><h1 id="JVM如何设置参数"><a href="#JVM如何设置参数" class="headerlink" title="JVM如何设置参数"></a>JVM如何设置参数</h1><h1 id="JVM性能调优"><a href="#JVM性能调优" class="headerlink" title="JVM性能调优"></a>JVM性能调优</h1><h1 id="类加载器、双亲委派模型、一个类的生命周期、类是如何加载到JVM中的"><a href="#类加载器、双亲委派模型、一个类的生命周期、类是如何加载到JVM中的" class="headerlink" title="类加载器、双亲委派模型、一个类的生命周期、类是如何加载到JVM中的"></a>类加载器、双亲委派模型、一个类的生命周期、类是如何加载到JVM中的</h1><h1 id="类加载的过程：加载、验证、准备、解析、初始化"><a href="#类加载的过程：加载、验证、准备、解析、初始化" class="headerlink" title="类加载的过程：加载、验证、准备、解析、初始化"></a>类加载的过程：加载、验证、准备、解析、初始化</h1><h1 id="强引用、软引用、弱引用、虚引用"><a href="#强引用、软引用、弱引用、虚引用" class="headerlink" title="强引用、软引用、弱引用、虚引用"></a>强引用、软引用、弱引用、虚引用</h1><h1 id="java内存模型"><a href="#java内存模型" class="headerlink" title="java内存模型"></a>java内存模型</h1><p>java内存模型，即JMM，java虚拟机规范定义了一种java内存模型来屏蔽掉各种硬件和操作系统之间的内存访问差异，使得java程序在各平台上有一致的内存访问效果<br>java程序中除线程私有变量之外的所有变量都保存在主内存之中<br>每条线程都有自己的工作内存，存放线程的私有变量（比如局部变量、方法参数、以及被线程使用到的变量值的主内存的副本拷贝）<br>线程对变量的所有操作都必须在工作内存中进行，不能直接读写主内存中的变量<br>线程间无法直接访问对方的工作内存，线程间值的传递必须通过主内存完成<br>JMM定义了8个操作来完成变量从主内存拷贝到工作内存，从工作内存同步回主内存，分别是：lock, unlock, read, load, use, assign, store, write<br>JMM还定义了许多规则<br>比如：<br>对于volatile型变量的特殊规则</p><ol><li>保证了被volatile修饰的变量对所有线程的可见性</li><li>禁止指令重排序优化<br>这里的可见性指的是：当一个线程修改了共享变量的值，新值对于其他线程来说是立即可见的<br>禁止指令重排序优化，引出了双锁检测实现单例<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Instance</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Instance instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Instance</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instance <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Instance.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Instance();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">对于<span class="keyword">long</span>,<span class="keyword">double</span>型变量的特殊规则</span><br><span class="line">非原子性协定</span><br><span class="line">指的是允许java虚拟机实现可以不保证<span class="number">64</span>为数据类型的load, store, read, write的原子性</span><br><span class="line"></span><br><span class="line">并发当中的三个特性：</span><br><span class="line">原子性</span><br><span class="line">可见性</span><br><span class="line">有序性</span><br><span class="line"></span><br><span class="line">大致可以认为所有基本类型的变量读写操作都是原子性的，例外情况就是非原子性协定，几乎不会出现，</span><br><span class="line">JMM提供了read, load, use, assign, store, write操作保证边变量的原子性</span><br><span class="line">对于更大范围的原子性保证，JMM提供了lock, unlock操作，它们对应与java字节码指令是moniterenter和mointerexit,而这两个字节码对应与java代码中的<span class="keyword">synchronized</span>关键字，所以sychronized代码块之间的操作也是原子性的</span><br><span class="line"></span><br><span class="line">可见性指的是，当一个线程修改了共享变量的值，新值对于其他线程来说是立即可见的，前面已经说过，<span class="keyword">volatile</span>变量的特殊规则保证了新值能立即同步到主内存，及要使用前能立即从主内存刷新。</span><br><span class="line">对于可见性，java语言提供了<span class="number">3</span>个关键字，<span class="keyword">synchronized</span>, <span class="keyword">volatile</span>, <span class="keyword">final</span></span><br><span class="line"></span><br><span class="line">有序性指的是，在线程中观察，所有代码都是有序的；在一个线程中观察另一个线程，所有代码都是无序的。前半句指的是程序内表现为串行语义，后半句指的是指令重排序和工作内存到主内存的同步延迟</span><br><span class="line"></span><br><span class="line">先行发生原则</span><br><span class="line">指的是JMM中定义的两个操作之间的偏序关系，如果操作A现行发生于操作B，也就是说在操作B发生之前，操作A产生的影响被操作B来观察到</span><br><span class="line">该原则的作用是，判断数据是否存在竞争，线程是否安全</span><br><span class="line"></span><br><span class="line">JMM中<span class="number">8</span>中先行发生关系</span><br><span class="line">程序次序原则</span><br><span class="line">管程锁定原则</span><br><span class="line"><span class="keyword">volatile</span>变量原则</span><br><span class="line">线程启动原则</span><br><span class="line">线程终止原则</span><br><span class="line">线程中断原则</span><br><span class="line">对象终结原则</span><br><span class="line">传递性原则</span><br></pre></td></tr></table></figure></li></ol><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1>]]></content>
      
      
    </entry>
    
    <entry>
      <title>beanFactory</title>
      <link href="/2018/06/26/beanFactory/"/>
      <url>/2018/06/26/beanFactory/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><a id="more"></a><p><img src="http://g.gravizo.com/svg?org.springframework.context.support.ClassPathXmlApplicationContext --|&gt; abstract org.springframework.context.support.AbstractXmlApplicationContext; abstract org.springframework.context.support.AbstractXmlApplicationContext --|&gt; abstract org.springframework.context.support.AbstractRefreshableApplicationContext; abstract org.springframework.context.support.AbstractXmlApplicationContext ..|&gt; interface org.springframework.beans.factory.BeanNameAware; abstract org.springframework.context.support.AbstractXmlApplicationContext ..|&gt; interface org.springframework.beans.factory.InitializingBean; interface org.springframework.beans.factory.BeanNameAware ..|&gt; interface org.springframework.beans.factory.Aware; abstract org.springframework.context.support.AbstractRefreshableApplicationContext --|&gt; abstract org.springframework.context.support.AbstractApplicationContext; abstract org.springframework.context.support.AbstractApplicationContext --|&gt; org.springframework.core.io.DefaultResourceLoader; abstract org.springframework.context.support.AbstractApplicationContext ..|&gt; interface org.springframework.context.ConfigurableApplicationContext; abstract  org.springframework.context.support.AbstractApplicationContext ..|&gt; interface org.springframework.beans.factory.DisposableBean; org.springframework.core.io.DefaultResourceLoader ..|&gt; interface org.springframework.core.io.ResourceLoader; interface org.springframework.context.ConfigurableApplicationContext --|&gt; interface org.springframework.context.ApplicationContext; interface org.springframework.context.ConfigurableApplicationContext --|&gt; interface org.springframework.context.Lifecycle; interface org.springframework.context.ConfigurableApplicationContext --|&gt; interface java.io.Closeable; java.io.Closeable --|&gt; interface java.io.AutoCloseable; interface org.springframework.context.ApplicationContext --|&gt; interface org.springframework.core.env.EnvironmentCapable; interface org.springframework.context.ApplicationContext --|&gt; interface org.springframework.beans.factory.ListableBeanFactory; interface org.springframework.context.ApplicationContext --|&gt; interface org.springframework.beans.factory.HierarchicalBeanFactory; interface org.springframework.context.ApplicationContext --|&gt; interface org.springframework.context.MessageSource; interface org.springframework.context.ApplicationContext --|&gt; interface org.springframework.context.ApplicationEventPublisher; interface org.springframework.context.ApplicationContext --|&gt; interface org.springframework.core.io.support.ResourcePatternResolver; interface org.springframework.beans.factory.ListableBeanFactory --|&gt; interface org.springframework.beans.factory.BeanFactory; interface org.springframework.beans.factory.HierarchicalBeanFactory --|&gt; interface org.springframework.beans.factory.BeanFactory; interface org.springframework.core.io.support.ResourcePatternResolver --|&gt; interface org.springframework.core.io.ResourceLoader" alt="ClassPathXmlApplicationContext"></p><p><img src="http://g.gravizo.com/svg?interface org.springframework.beans.factory.BeanFactory &lt;|-- interface org.springframework.beans.factory.HierarchicalBeanFactory; interface org.springframework.beans.factory.BeanFactory &lt;|-- interface org.springframework.beans.factory.config.AutowireCapableBeanFactory; interface org.springframework.beans.factory.BeanFactory &lt;|-- interface org.springframework.beans.factory.ListableBeanFactory; interface org.springframework.beans.factory.BeanFactory &lt;|-- org.springframework.jndi.support.SimpleJndiBeanFactory; interface org.springframework.beans.factory.HierarchicalBeanFactory &lt;|-- interface org.springframework.beans.factory.config.ConfigurableBeanFactory; interface org.springframework.beans.factory.HierarchicalBeanFactory &lt;|-- interface org.springframework.context.ApplicationContext; interface org.springframework.beans.factory.config.AutowireCapableBeanFactory &lt;|-- interface org.springframework.beans.factory.config.ConfigurableListableBeanFactory; interface org.springframework.beans.factory.config.AutowireCapableBeanFactory &lt;|.. org.springframework.test.web.servlet.setup.StubWebApplicationContext.StubBeanFactory; interface org.springframework.beans.factory.config.AutowireCapableBeanFactory &lt;|.. abstract org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory; interface org.springframework.beans.factory.ListableBeanFactory &lt;|.. org.springframework.beans.factory.support.StaticListableBeanFactory; interface org.springframework.beans.factory.ListableBeanFactory &lt;|-- interface org.springframework.context.ApplicationContext; interface org.springframework.beans.factory.ListableBeanFactory &lt;|-- interface org.springframework.beans.factory.config.ConfigurableListableBeanFactory; interface org.springframework.beans.factory.config.ConfigurableBeanFactory &lt;|.. abstract org.springframework.beans.factory.support.AbstractBeanFactory; interface org.springframework.beans.factory.config.ConfigurableBeanFactory &lt;|-- interface org.springframework.beans.factory.config.ConfigurableListableBeanFactory; interface org.springframework.context.ApplicationContext &lt;|-- interface org.springframework.context.ConfigurableApplicationContext; interface org.springframework.beans.factory.config.ConfigurableListableBeanFactory &lt;|.. org.springframework.beans.factory.support.DefaultListableBeanFactory; abstract org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory &lt;|-- org.springframework.beans.factory.support.DefaultListableBeanFactory; org.springframework.beans.factory.support.StaticListableBeanFactory &lt;|-- org.springframework.test.web.servlet.setup.StubWebApplicationContext.StubBeanFactory; interface org.springframework.context.ApplicationContext &lt;|-- interface org.springframework.context.ConfigurableApplicationContext; interface org.springframework.beans.factory.config.ConfigurableListableBeanFactory &lt;|.. org.springframework.beans.factory.support.DefaultListableBeanFactory; org.springframework.beans.factory.support.DefaultListableBeanFactory &lt;|.. org.springframework.beans.factory.xml.XmlBeanFactory; interface org.springframework.context.ConfigurableApplicationContext &lt;|.. abstract org.springframework.context.support.AbstractApplicationContext; abstract org.springframework.context.support.AbstractApplicationContext &lt;|-- abstract org.springframework.context.support.AbstractRefreshableApplicationContext; abstract org.springframework.context.support.AbstractRefreshableApplicationContext &lt;|-- abstract org.springframework.context.support.AbstractRefreshableConfigApplicationContext; abstract org.springframework.context.support.AbstractRefreshableConfigApplicationContext &lt;|-- abstract org.springframework.context.support.AbstractXmlApplicationContext; abstract org.springframework.context.support.AbstractXmlApplicationContext &lt;|-- org.springframework.context.support.FileSystemXmlApplicationContext; abstract org.springframework.context.support.AbstractXmlApplicationContext &lt;|-- org.springframework.context.support.ClassPathXmlApplicationContext; abstract org.springframework.context.support.AbstractApplicationContext &lt;|-- org.springframework.context.support.GenericApplicationContext; org.springframework.context.support.GenericApplicationContext &lt;|-- org.springframework.context.support.GenericXmlApplicationContext; org.springframework.context.support.GenericApplicationContext &lt;|-- org.springframework.context.support.StaticApplicationContext; org.springframework.context.support.GenericApplicationContext &lt;|-- org.springframework.context.support.GenericGroovyApplicationContext; org.springframework.context.support.GenericApplicationContext &lt;|-- org.springframework.context.support.AnnotationConfigApplicationContext; org.springframework.beans.factory.support.DefaultListableBeanFactory &lt;|-- org.springframework.beans.factory.xml.XmlBeanFactory;" alt="BeanFactory"></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1>]]></content>
      
      
    </entry>
    
    <entry>
      <title>消息队列</title>
      <link href="/2018/05/31/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
      <url>/2018/05/31/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul><li>为什么要使用消息队列?</li><li>使用了消息队列会有什么缺点?</li><li>消息队列如何选型?</li><li>如何保证消息队列是高可用的？</li><li>如何保证消息不被重复消费？</li><li>如何保证消费的可靠性传输?</li><li>如何保证消息的顺序性？</li></ul><a id="more"></a><h1 id="为什么要使用消息队列"><a href="#为什么要使用消息队列" class="headerlink" title="为什么要使用消息队列"></a>为什么要使用消息队列</h1><h2 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h2><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><h2 id="削峰"><a href="#削峰" class="headerlink" title="削峰"></a>削峰</h2><h1 id="使用了消息队列会有什么缺点"><a href="#使用了消息队列会有什么缺点" class="headerlink" title="使用了消息队列会有什么缺点"></a>使用了消息队列会有什么缺点</h1><h2 id="系统可用性降低"><a href="#系统可用性降低" class="headerlink" title="系统可用性降低"></a>系统可用性降低</h2><h2 id="系统复杂性增加"><a href="#系统复杂性增加" class="headerlink" title="系统复杂性增加"></a>系统复杂性增加</h2><h1 id="消息队列如何选型"><a href="#消息队列如何选型" class="headerlink" title="消息队列如何选型"></a>消息队列如何选型</h1><h2 id="中小型软件公司，建议选RabbitMQ"><a href="#中小型软件公司，建议选RabbitMQ" class="headerlink" title="中小型软件公司，建议选RabbitMQ"></a>中小型软件公司，建议选RabbitMQ</h2><h2 id="大型软件公司，根据具体使用在rocketMq和kafka之间二选一"><a href="#大型软件公司，根据具体使用在rocketMq和kafka之间二选一" class="headerlink" title="大型软件公司，根据具体使用在rocketMq和kafka之间二选一"></a>大型软件公司，根据具体使用在rocketMq和kafka之间二选一</h2><h1 id="如何保证消息队列是高可用的"><a href="#如何保证消息队列是高可用的" class="headerlink" title="如何保证消息队列是高可用的"></a>如何保证消息队列是高可用的</h1><p>消息队列的集群模式</p><h1 id="如何保证消息不被重复消费-or-如何保证消息队列的幂等性"><a href="#如何保证消息不被重复消费-or-如何保证消息队列的幂等性" class="headerlink" title="如何保证消息不被重复消费 or 如何保证消息队列的幂等性"></a>如何保证消息不被重复消费 or 如何保证消息队列的幂等性</h1><p>原因：<br>网络传输等等故障，确认信息没有传送到消息队列，导致消息队列不知道自己已经消费过该消息了，再次将该消息分发给其他的消费者</p><h1 id="如何保证消费的可靠性传输"><a href="#如何保证消费的可靠性传输" class="headerlink" title="如何保证消费的可靠性传输"></a>如何保证消费的可靠性传输</h1><p>其实这个可靠性传输，每种MQ都要从三个角度来分析:生产者弄丢数据、消息队列弄丢数据、消费者弄丢数据</p><h2 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h2><p>发送数据，开启事务</p><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>持久化数据之后再向生产者确认</p><h2 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h2><p>消费成功之后确认消息，不要采用自动确认的消息模式</p><h1 id="如何保证消息的顺序性"><a href="#如何保证消息的顺序性" class="headerlink" title="如何保证消息的顺序性"></a>如何保证消息的顺序性</h1><p>通过某种算法，将需要保持先后顺序的消息放到同一个消息队列中(kafka中就是partition,rabbitMq中就是queue)。然后只用一个消费者去消费该队列。<br>保证入队有序就行，出队以后的顺序交给消费者自己去保证，没有固定套路</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://mp.weixin.qq.com/s?__biz=MzU0OTE4MzYzMw==&amp;mid=2247484799&amp;idx=1&amp;sn=bc98c5b88a276ce113de633800b6cdb8&amp;chksm=fbb28c81ccc505974e163faf38afc08ecafe6ae3c68b8b3d9993c214650dc7b4fe75c49006ac&amp;mpshare=1&amp;scene=23&amp;srcid=0531L6FSQOszDoWxcyQM1Hfj%23rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzU0OTE4MzYzMw==&amp;mid=2247484799&amp;idx=1&amp;sn=bc98c5b88a276ce113de633800b6cdb8&amp;chksm=fbb28c81ccc505974e163faf38afc08ecafe6ae3c68b8b3d9993c214650dc7b4fe75c49006ac&amp;mpshare=1&amp;scene=23&amp;srcid=0531L6FSQOszDoWxcyQM1Hfj%23rd</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>成为java高级程序员需要掌握哪些</title>
      <link href="/2018/05/31/%E6%88%90%E4%B8%BAjava%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E5%93%AA%E4%BA%9B/"/>
      <url>/2018/05/31/%E6%88%90%E4%B8%BAjava%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E5%93%AA%E4%BA%9B/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><a id="more"></a><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://mp.weixin.qq.com/s?__biz=MzA3ODQ0Mzg2OA==&amp;mid=2649047703&amp;idx=1&amp;sn=d04a7427d89708016dcb7400529328f1&amp;chksm=875346a4b024cfb2f67810df77722a885cf4732ef8cf17f6fcfb52ac690d5b4a6c585c79a145&amp;mpshare=1&amp;scene=23&amp;srcid=0531ilcdBgUXBf2LGI5B7so4%23rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzA3ODQ0Mzg2OA==&amp;mid=2649047703&amp;idx=1&amp;sn=d04a7427d89708016dcb7400529328f1&amp;chksm=875346a4b024cfb2f67810df77722a885cf4732ef8cf17f6fcfb52ac690d5b4a6c585c79a145&amp;mpshare=1&amp;scene=23&amp;srcid=0531ilcdBgUXBf2LGI5B7so4%23rd</a></p>]]></content>
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>分布式事务</title>
      <link href="/2018/05/30/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
      <url>/2018/05/30/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote><p>在编程中.一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同</p></blockquote><a id="more"></a><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.i3geek.com/archives/841" target="_blank" rel="noopener">https://www.i3geek.com/archives/841</a><br><a href="https://www.i3geek.com/archives/841" target="_blank" rel="noopener">https://www.i3geek.com/archives/841</a><br><a href="https://www.jianshu.com/p/21f7fdfd9906" target="_blank" rel="noopener">https://www.jianshu.com/p/21f7fdfd9906</a></p>]]></content>
      
      <categories>
          
          <category> Transction </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 事务 </tag>
            
            <tag> 分布式 </tag>
            
            <tag> 分布式事务 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DDos攻击</title>
      <link href="/2018/05/23/DDos%E6%94%BB%E5%87%BB/"/>
      <url>/2018/05/23/DDos%E6%94%BB%E5%87%BB/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>DDos攻击，即分布式拒绝服务</p><ul><li>DDos攻击的原理</li><li>如何防御DDos攻击<a id="more"></a></li></ul><h1 id="DDos攻击的原理"><a href="#DDos攻击的原理" class="headerlink" title="DDos攻击的原理"></a>DDos攻击的原理</h1><p>它是利用TCP连接三次握手的原理，发送大量的建立连接的网络包，但不实际建立连接，最终导致被攻击服务器的网络队列被占满，服务被正常用户访问。</p><h1 id="如何防御DDos攻击"><a href="#如何防御DDos攻击" class="headerlink" title="如何防御DDos攻击"></a>如何防御DDos攻击</h1><ul><li>充分利用网络设备保护网络资源，比如路由器限制SYN/ICMP的最大流量，防火墙限制特定IP，过滤攻击时伪造的大量虚假内部IP（Internet内部保留的区域性IP地址），启用防火墙的防DDos属性</li><li>服务器自身定期扫描安全漏洞，升级补丁，关闭不必要的服务，限制最大SYN半连接数目，缩短SYN半连接time out时间等<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1></li></ul><p><a href="https://blog.csdn.net/huwei2003/article/details/45476743" target="_blank" rel="noopener">https://blog.csdn.net/huwei2003/article/details/45476743</a></p><p><a href="https://www.jianshu.com/p/cacfe5749e81" target="_blank" rel="noopener">https://www.jianshu.com/p/cacfe5749e81</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Java动态代理</title>
      <link href="/2018/05/22/Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
      <url>/2018/05/22/Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote><p>Java的动态代理，是指利用Java反射技术在运行期创建实现某些特定接口的新类及其实例，代理的是接口，不是抽象类，更不是类。</p></blockquote><ul><li>动态代理的作用</li></ul><a id="more"></a><h1 id="动态代理的作用"><a href="#动态代理的作用" class="headerlink" title="动态代理的作用"></a>动态代理的作用</h1><ol><li>一个接口的实现在编译时无法知道，需要在运行时才能实现</li><li>实现适配器模式、装饰者模式等设计模式</li><li>面向切面编程，AOP技术</li></ol><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.cnblogs.com/techyc/p/3455950.html" target="_blank" rel="noopener">https://www.cnblogs.com/techyc/p/3455950.html</a></p>]]></content>
      
      <categories>
          
          <category> JDK </category>
          
          <category> Proxy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态代理 </tag>
            
            <tag> Proxy </tag>
            
            <tag> Reflection </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>zookeeper简介</title>
      <link href="/2018/05/18/zookeeper%E7%AE%80%E4%BB%8B/"/>
      <url>/2018/05/18/zookeeper%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul><li>什么是zookeeper?</li><li>什么是分布式系统？<br>zookeeper是一个中间件，为分布式系统提供协调服务<br>分布式系统就是很多台计算机组成一个整体，一致对外并且处理同一个请求；内部每台计算机都可以相互通信（rest/rpc);客户端到服务端的一次请求到相应结束会经历对台计算机<a id="more"></a></li></ul><p>分布式文件系统——俗称网盘</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1>]]></content>
      
      <categories>
          
          <category> ZooKeeper </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>volatile的实现原理</title>
      <link href="/2018/05/16/volatile%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>/2018/05/16/volatile%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul><li>volatile的两个语义<a id="more"></a></li></ul><h1 id="volatile的两个语义是什么"><a href="#volatile的两个语义是什么" class="headerlink" title="volatile的两个语义是什么"></a>volatile的两个语义是什么</h1><ol><li>保证变量对所有线程的可见性</li><li>禁止机器级别的指令重排序优化</li></ol><h2 id="volatile如何保证变量对所有线程的可见性的"><a href="#volatile如何保证变量对所有线程的可见性的" class="headerlink" title="volatile如何保证变量对所有线程的可见性的"></a>volatile如何保证变量对所有线程的可见性的</h2><p>当一个变量被volatile关键字修饰之后，如果某个线程修改了该变量的值，其他线程会得到更新通知，其他线程在使用该变量时就会去主内存中刷新该变量的值</p><h2 id="volatile是如何禁止机器级别的指令重排序优化的"><a href="#volatile是如何禁止机器级别的指令重排序优化的" class="headerlink" title="volatile是如何禁止机器级别的指令重排序优化的"></a>volatile是如何禁止机器级别的指令重排序优化的</h2><p>通过反汇编机器指令，可以看到被volatile修饰的变量在赋值后多了一个lock操作，这个操作相当于一个内存屏障，重排序时不能把lock之后的指令重排序到lock之前，对应到DCL例子来说，就是返回实例对象这个操作对应的指令不能在给volatile变量赋值之前执行，保证了其他线程拿到实例对象是可用的，是已经正确实例化的对象</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p>《深入理解Java虚拟机·JVM高级特性与最佳实践》第12章 Java内存模型与线程 12.3.4节</p>]]></content>
      
      <categories>
          
          <category> JDK </category>
          
          <category> Concurrent </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Concurrent </tag>
            
            <tag> volatile </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>信号Signal和信号量Semaphore</title>
      <link href="/2018/05/16/%E4%BF%A1%E5%8F%B7Signal%E5%92%8C%E4%BF%A1%E5%8F%B7%E9%87%8FSemaphore/"/>
      <url>/2018/05/16/%E4%BF%A1%E5%8F%B7Signal%E5%92%8C%E4%BF%A1%E5%8F%B7%E9%87%8FSemaphore/</url>
      <content type="html"><![CDATA[<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://blog.csdn.net/langjian2012/article/details/39717903" target="_blank" rel="noopener">https://blog.csdn.net/langjian2012/article/details/39717903</a></p><p><a href="http://www.importnew.com/22519.html" target="_blank" rel="noopener">http://www.importnew.com/22519.html</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>JDK常用的命令行工具</title>
      <link href="/2018/05/15/JDK%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"/>
      <url>/2018/05/15/JDK%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</url>
      <content type="html"><![CDATA[<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="http://www.importnew.com/18398.html" target="_blank" rel="noopener">http://www.importnew.com/18398.html</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Thread的生命周期</title>
      <link href="/2018/05/15/Thread%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2018/05/15/Thread%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul><li>Java的Thread生命周期中有几个状态？</li><li>Java的Thread生命周期中的状态是怎么转换的？</li></ul><a id="more"></a><h1 id="Java的Thread生命周期中有6个状态"><a href="#Java的Thread生命周期中有6个状态" class="headerlink" title="Java的Thread生命周期中有6个状态"></a>Java的Thread生命周期中有6个状态</h1><p>参考JDK API 1.8 java.lang.Thread.State</p><ul><li><strong>NEW</strong> <code>新建状态，还没有执行Thread.start()方法时所处的状态</code></li><li><strong>RUNNABLE</strong> <code>可执行状态，在等待系统资源，比如处理器</code></li><li><strong>BLOCKED</strong> <code>阻塞状态，线程在同步代码块中等待获取锁</code></li><li><strong>WAITING</strong> <code>等待状态，当线程调用了如下的方法时就会进入该状态，比如：调用Object.wait()没有超时, Thread.join()没有超时, LockSupport.park()</code></li><li><strong>TIMED_WAITING</strong> <code>超时等待状态，当线程调用了如下的方法时就会进入该状态，比如：调用Object.wait(long), Thread.join(long), LockSuport.parkNanos(), LockSupport.parkUntil()</code></li><li><strong>TERMINATED</strong> <code>终止状态，线程运行完run（）方法之后就会进入该状态</code></li></ul><p><strong>这里有个疑问：</strong> 为什么BLOCKED状态是在线程调用了Objcet.wait()方法之后进入的，而WAITING状态也是线程调用Object.wait()方法进入的，那当线程调用Object.wait()方法之后是进入BLOCKED状态呢，还是进入WAITING状态呢？</p><h1 id="Java的Thread生命周期中的状态是怎么转换的？"><a href="#Java的Thread生命周期中的状态是怎么转换的？" class="headerlink" title="Java的Thread生命周期中的状态是怎么转换的？"></a>Java的Thread生命周期中的状态是怎么转换的？</h1><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.zhihu.com/question/27654579" target="_blank" rel="noopener">https://www.zhihu.com/question/27654579</a></p>]]></content>
      
      <categories>
          
          <category> JDK </category>
          
          <category> Thread </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDK </tag>
            
            <tag> Thread </tag>
            
            <tag> wait </tag>
            
            <tag> notify </tag>
            
            <tag> join </tag>
            
            <tag> sleep </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>队列相关问题</title>
      <link href="/2018/05/14/%E9%98%9F%E5%88%97%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
      <url>/2018/05/14/%E9%98%9F%E5%88%97%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ol><li>LinkedBlockingQueue的实现原理</li><li>ArrayBlockingQueue的实现原理</li><li>SynchronousQueue的实现原理</li></ol><a id="more"></a><h1 id="BlockingQueue提供的方法分析"><a href="#BlockingQueue提供的方法分析" class="headerlink" title="BlockingQueue提供的方法分析"></a>BlockingQueue提供的方法分析</h1><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">抛出异常</th><th style="text-align:center">返回特殊值</th><th style="text-align:center">一直阻塞</th><th style="text-align:center">超时退出</th></tr></thead><tbody><tr><td style="text-align:center">插入方法</td><td style="text-align:center">add(e)</td><td style="text-align:center">offer(e)</td><td style="text-align:center">put(e)</td><td style="text-align:center">offer(e, time unit)</td></tr><tr><td style="text-align:center">移除方法</td><td style="text-align:center">remove()</td><td style="text-align:center">poll()</td><td style="text-align:center">take()</td><td style="text-align:center">poll(time, unit)</td></tr><tr><td style="text-align:center">检查方法</td><td style="text-align:center">element()</td><td style="text-align:center">peek()</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr></tbody></table><h1 id="LinkedBlockingQueue的实现原理"><a href="#LinkedBlockingQueue的实现原理" class="headerlink" title="LinkedBlockingQueue的实现原理"></a>LinkedBlockingQueue的实现原理</h1><ul><li>LinkedBlockingQueue在构造时可以指定队列大小，如果不指定，默认使用Integer.MAX_VALUE;</li><li>add方法继承自AbstractQueue,实质上是调用offer方法向队列中加入元素，不管是offer还是put都不允许被加入的元素是null，否则将抛出空指针异常；</li><li>内部有两把重入锁，分别是putLock和takeLock,还有两个条件,分别是putLock创建的notFull,以及takeLock创建的notEmpty,不同的锁对应元素的入队和出队操作，提高并发的效率，比如putLock锁在生产者向队列添加元素时起作用，而takeLock锁在消费者在队列获取元素时起作用；不同的条件，可以通知不同的线程，比如notEmpty条件会通知所有消费者线程，notFull条件会通知所有生产者线程</li><li></li></ul><h2 id="LinkedBlockingQueue类图"><a href="#LinkedBlockingQueue类图" class="headerlink" title="LinkedBlockingQueue类图"></a>LinkedBlockingQueue类图</h2><p><img src="http://g.gravizo.com/svg?abstract java.util.AbstractQueue &lt;|-- java.util.concurrent.LinkedBlockingQueue; interface java.util.concurrent.BlockingQueue &lt;|.. java.util.concurrent.LinkedBlockingQueue; abstract java.util.AbstractCollection &lt;|-- abstract java.util.AbstractQueue; interface java.util.Queue &lt;|.. abstract java.util.AbstractQueue; java.util.Collection &lt;|.. abstract java.util.AbstractCollection; interface java.util.Collection &lt;|-- interface java.util.Queue; interface java.util.Queue &lt;|-- interface java.util.concurrent.BlockingQueue;" alt="LinkedBlockingQueue类图"></p><h1 id="ArrayBlockingQueue的实现原理"><a href="#ArrayBlockingQueue的实现原理" class="headerlink" title="ArrayBlockingQueue的实现原理"></a>ArrayBlockingQueue的实现原理</h1><h2 id="ArrayBlockingQueue类图"><a href="#ArrayBlockingQueue类图" class="headerlink" title="ArrayBlockingQueue类图"></a>ArrayBlockingQueue类图</h2><p><img src="http://g.gravizo.com/svg?java.util.concurrent.ArrayBlockingQueue --|&gt; abstract java.util.AbstractQueue;java.util.concurrent.ArrayBlockingQueue ..|&gt; interface java.util.concurrent.BlockingQueue;abstract java.util.AbstractQueue --|&gt; abstract java.util.AbstractCollection;abstract java.util.AbstractQueue ..|&gt; interface java.util.Queue;interface java.util.Queue --|&gt; interface java.util.Collection;abstract java.util.AbstractCollection ..|&gt; interface java.util.Collection;interface java.util.concurrent.BlockingQueue --|&gt; interface java.util.Queue;" alt="ArrayBlockingQueue类图"></p><h1 id="SynchronousQueue的实现原理"><a href="#SynchronousQueue的实现原理" class="headerlink" title="SynchronousQueue的实现原理"></a>SynchronousQueue的实现原理</h1><h2 id="SynchronousQueue类图"><a href="#SynchronousQueue类图" class="headerlink" title="SynchronousQueue类图"></a>SynchronousQueue类图</h2><p><img src="http://g.gravizo.com/svg?java.util.concurrent.SynchronousQueue --|&gt; abstract java.util.AbstractQueue;java.util.concurrent.SynchronousQueue ..|&gt; interface java.util.concurrent.BlockingQueue;abstract java.util.AbstractQueue --|&gt; abstract java.util.AbstractCollection;abstract java.util.AbstractQueue ..|&gt; interface java.util.Queue;interface java.util.Queue --|&gt; interface java.util.Collection;abstract java.util.AbstractCollection ..|&gt; interface java.util.Collection;interface java.util.concurrent.BlockingQueue --|&gt; interface java.util.Queue;" alt="SynchronousQueue类图"></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://segmentfault.com/a/1190000004911771" target="_blank" rel="noopener">https://segmentfault.com/a/1190000004911771</a></p><p><a href="https://www.cnblogs.com/lyysz/p/5913264.html" target="_blank" rel="noopener">https://www.cnblogs.com/lyysz/p/5913264.html</a></p>]]></content>
      
      <categories>
          
          <category> JDK </category>
          
          <category> Collections </category>
          
          <category> Queue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> List </tag>
            
            <tag> LinkedList </tag>
            
            <tag> BlockingQueue </tag>
            
            <tag> Queue </tag>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java中的反斜杠0是什么意思</title>
      <link href="/2018/05/11/Java%E4%B8%AD%E7%9A%84%E5%8F%8D%E6%96%9C%E6%9D%A00%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D/"/>
      <url>/2018/05/11/Java%E4%B8%AD%E7%9A%84%E5%8F%8D%E6%96%9C%E6%9D%A00%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Java中<code>char a = &#39;\0&#39;;</code>给一个字符变量赋值为<code>&#39;\0&#39;</code>表示什么意思？<code>char a = &#39;0&#39;</code>又表示什么意思？</p><ul><li><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.jiuzhang.com/qa/3583/" target="_blank" rel="noopener">https://www.jiuzhang.com/qa/3583/</a></p></li></ul><p><a href="https://bbs.csdn.net/topics/390544484" target="_blank" rel="noopener">https://bbs.csdn.net/topics/390544484</a></p><p><a href="http://ascii.911cha.com/" target="_blank" rel="noopener">http://ascii.911cha.com/</a></p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> char </tag>
            
            <tag> 字符变量 </tag>
            
            <tag> ASCII码 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Shell脚本批量发送POST请求</title>
      <link href="/2018/05/10/Shell%E8%84%9A%E6%9C%AC%E6%89%B9%E9%87%8F%E5%8F%91%E9%80%81POST%E8%AF%B7%E6%B1%82/"/>
      <url>/2018/05/10/Shell%E8%84%9A%E6%9C%AC%E6%89%B9%E9%87%8F%E5%8F%91%E9%80%81POST%E8%AF%B7%E6%B1%82/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><a id="more"></a><h1 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h1><h2 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h2><p>命令行前面放eval，在执行命令之前，它将被扫描两次</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pipe=<span class="string">"|"</span></span><br><span class="line"><span class="built_in">eval</span> ls <span class="variable">$pipe</span> wc -c</span><br></pre></td></tr></table></figure><p>shell第1次扫描命令行时，它替换出pipe的值｜，接着eval使它再次扫描命令行，这时shell把｜作为管道符号了。</p><p>如果变量中包含任何需要shell直接在命令行中看到的字符（不是替换的结果），就可以使用eval。命令行结束符（；｜ &amp;），I／o重定向符（&lt; &gt;）和引号就属于对shell具有特殊意义的符号，必须直接出现在命令行中。</p><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line"></span><br><span class="line">ip=10.12.102.134</span><br><span class="line">port=7080</span><br><span class="line">cat data | while read i</span><br><span class="line">do</span><br><span class="line">    line=$i</span><br><span class="line">    source_id=`echo $line | cut -d ' '  -f 1`</span><br><span class="line">    item_code=`echo $line | cut -d ' '  -f 2`</span><br><span class="line">    description=`echo $line | cut -d ' '  -f 3`</span><br><span class="line">    address=`echo $line | cut -d ' '  -f 4`</span><br><span class="line">    area_code=`echo $line | cut -d ' '  -f 5`</span><br><span class="line">    longitude=`echo $line | cut -d ' '  -f 6`</span><br><span class="line">    latitude=`echo $line | cut -d ' '  -f 7`</span><br><span class="line">    echo $source_id</span><br><span class="line">    echo $item_code</span><br><span class="line">    echo $description</span><br><span class="line">    echo $address</span><br><span class="line">    echo $area_code</span><br><span class="line">    echo $longitude</span><br><span class="line">    echo $latitude</span><br><span class="line">    send_data='&#123;"sourceId":"'$source_id'", "itemCode":"'$item_code'", "description":"'$description'", "address":"'$address'","areaCode":"'$area_code'", "longitude":"'$longitude'", "latitude":"'$latitude'","files":[], "data":&#123;&#125;&#125;'</span><br><span class="line">    send_data="'"$send_data"'"</span><br><span class="line">    param=' -d '$send_data</span><br><span class="line">    command='curl -X POST http://'$ip':'$port'/dcm-web/caseApi/addCase.json -H "Content-Type:application/json"'$param</span><br><span class="line">    # curl -X POST http://$ip:$port/dcm-web/caseApi/addCase.json -H "Content-Type: application/json" $param</span><br><span class="line">    echo $command</span><br><span class="line">    eval $command</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="http://www.cnblogs.com/dwdxdy/archive/2012/07/25/2608816.html" target="_blank" rel="noopener">http://www.cnblogs.com/dwdxdy/archive/2012/07/25/2608816.html</a></p><p><a href="http://blog.zengrong.net/post/1591.html" target="_blank" rel="noopener">http://blog.zengrong.net/post/1591.html</a></p><p><a href="https://droidyue.com/blog/2014/07/02/send-post-request-using-curl/" target="_blank" rel="noopener">https://droidyue.com/blog/2014/07/02/send-post-request-using-curl/</a></p><p><a href="https://blog.csdn.net/wanruirui/article/details/5975867" target="_blank" rel="noopener">https://blog.csdn.net/wanruirui/article/details/5975867</a></p><p><a href="http://blog.51cto.com/363918/1341977" target="_blank" rel="noopener">http://blog.51cto.com/363918/1341977</a></p>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
          <category> Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bash </tag>
            
            <tag> for循环 </tag>
            
            <tag> curl </tag>
            
            <tag> post </tag>
            
            <tag> json </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>其他面试相关问题</title>
      <link href="/2018/05/10/%E5%85%B6%E4%BB%96%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
      <url>/2018/05/10/%E5%85%B6%E4%BB%96%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>1.4、锁机制<br>说说线程安全问题，什么是线程安全，如何保证线程安全</p><p>重入锁的概念，重入锁为什么可以防止死锁</p><p>产生死锁的四个条件（互斥、请求与保持、不剥夺、循环等待）</p><p>如何检查死锁（通过jConsole检查死锁）</p><p>volatile 实现原理（禁止指令重排、刷新内存）</p><a id="more"></a><p>synchronized 实现原理（对象监视器）</p><p>synchronized 与 lock 的区别</p><p>AQS同步队列</p><p>CAS无锁的概念、乐观锁和悲观锁</p><p>常见的原子操作类</p><p>什么是ABA问题，出现ABA问题JDK是如何解决的</p><p>乐观锁的业务场景及实现方式</p><p>Java 8并法包下常见的并发类</p><p>偏向锁、轻量级锁、重量级锁、自旋锁的概念</p><p>1.5、JVM<br>JVM运行时内存区域划分</p><p>内存溢出OOM和堆栈溢出SOE的示例及原因、如何排查与解决</p><p>如何判断对象是否可以回收或存活</p><p>常见的GC回收算法及其含义</p><p>常见的JVM性能监控和故障处理工具类：jps、jstat、jmap、jinfo、jconsole等</p><p>JVM如何设置参数</p><p>JVM性能调优</p><p>类加载器、双亲委派模型、一个类的生命周期、类是如何加载到JVM中的</p><p>类加载的过程：加载、验证、准备、解析、初始化</p><p>强引用、软引用、弱引用、虚引用</p><p>Java内存模型JMM</p><p>1.6、设计模式<br>常见的设计模式</p><p>设计模式的的六大原则及其含义</p><p>常见的单例模式以及各种实现方式的优缺点，哪一种最好，手写常见的单利模式</p><p>设计模式在实际场景中的应用</p><p>Spring中用到了哪些设计模式</p><p>MyBatis中用到了哪些设计模式</p><p>你项目中有使用哪些设计模式</p><p>说说常用开源框架中设计模式使用分析</p><p>动态代理很重要！！！</p><p>1.7、数据结构</p><p>树（二叉查找树、平衡二叉树、红黑树、B树、B+树）</p><p>深度有限算法、广度优先算法</p><p>克鲁斯卡尔算法、普林母算法、迪克拉斯算法</p><p>什么是一致性Hash及其原理、Hash环问题</p><p>常见的排序算法和查找算法：快排、折半查找、堆排序等</p><p>1.8、网络/IO基础<br>BIO、NIO、AIO的概念</p><p>什么是长连接和短连接</p><p>Http1.0和2.0相比有什么区别，可参考《Http 2.0》</p><p>Https的基本概念</p><p>三次握手和四次挥手、为什么挥手需要四次</p><p>从游览器中输入URL到页面加载的发生了什么？可参考《从输入URL到页面加载发生了什么》</p><p>二、数据存储和消息队列</p><p>2.1、数据库<br>MySQL 索引使用的注意事项</p><p>DDL、DML、DCL分别指什么</p><p>explain命令</p><p>left join，right join，inner join</p><p>数据库事物ACID（原子性、一致性、隔离性、持久性）</p><p>事物的隔离级别（读未提交、读以提交、可重复读、可序列化读）</p><p>脏读、幻读、不可重复读</p><p>数据库的几大范式</p><p>数据库常见的命令</p><p>说说分库与分表设计</p><p>分库与分表带来的分布式困境与应对之策（如何解决分布式下的分库分表，全局表？）</p><p>说说 SQL 优化之道</p><p>MySQL遇到的死锁问题、如何排查与解决</p><p>存储引擎的 InnoDB与MyISAM区别，优缺点，使用场景</p><p>索引类别（B+树索引、全文索引、哈希索引）、索引的原理</p><p>什么是自适应哈希索引（AHI）</p><p>为什么要用 B+tree作为MySQL索引的数据结构</p><p>聚集索引与非聚集索引的区别</p><p>遇到过索引失效的情况没，什么时候可能会出现，如何解决</p><p>limit 20000 加载很慢怎么解决</p><p>如何选择合适的分布式主键方案</p><p>选择合适的数据存储方案</p><p>常见的几种分布式ID的设计方案</p><p>常见的数据库优化方案，在你的项目中数据库如何进行优化的</p><p>2.2、Redis<br>Redis 有哪些数据类型，可参考《Redis常见的5种不同的数据类型详解》</p><p>Redis 内部结构</p><p>Redis 使用场景</p><p>Redis 持久化机制，可参考《使用快照和AOF将Redis数据持久化到硬盘中》</p><p>Redis 集群方案与实现</p><p>Redis 为什么是单线程的？</p><p>缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级</p><p>使用缓存的合理性问题</p><p>Redis常见的回收策略</p><p>2.3、消息队列<br>消息队列的使用场景</p><p>消息的重发补偿解决思路</p><p>消息的幂等性解决思路</p><p>消息的堆积解决思路</p><p>自己如何实现消息队列</p><p>如何保证消息的有序性</p><p>三、开源框架和容器<br>3.1、SSM/Servlet<br>Servlet的生命周期</p><p>转发与重定向的区别</p><p>BeanFactory 和 ApplicationContext 有什么区别</p><p>Spring Bean 的生命周期</p><p>Spring IOC 如何实现</p><p>Spring中Bean的作用域，默认的是哪一个</p><p>说说 Spring AOP、Spring AOP 实现原理</p><p>动态代理（CGLib 与 JDK）、优缺点、性能对比、如何选择</p><p>Spring 事务实现方式、事务的传播机制、默认的事务类别</p><p>Spring 事务底层原理</p><p>Spring事务失效（事务嵌套），JDK动态代理给Spring事务埋下的坑，可参考《JDK动态代理给Spring事务埋下的坑！》</p><p>如何自定义注解实现功能</p><p>Spring MVC 运行流程</p><p>Spring MVC 启动流程</p><p>Spring 的单例实现原理</p><p>Spring 框架中用到了哪些设计模式</p><p>Spring 其他产品（Srping Boot、Spring Cloud、Spring Secuirity、Spring Data、Spring AMQP 等）</p><p>有没有用到Spring Boot，Spring Boot的认识、原理</p><p>MyBatis的原理</p><p>可参考《为什么会有Spring》</p><p>可参考《为什么会有Spring AOP》</p><p>3.2、Netty<br>为什么选择 Netty</p><p>说说业务中，Netty 的使用场景</p><p>原生的 NIO 在 JDK 1.7 版本存在 epoll bug</p><p>什么是TCP 粘包/拆包</p><p>TCP粘包/拆包的解决办法</p><p>Netty 线程模型</p><p>说说 Netty 的零拷贝</p><p>Netty 内部执行流程</p><p>Netty 重连实现</p><p>3.3、Tomcat</p><p>Tomcat的基础架构（Server、Service、Connector、Container）</p><p>Tomcat如何加载Servlet的</p><p>Pipeline-Valve机制</p><p>可参考：《四张图带你了解Tomcat系统架构！》</p><p>四、分布式<br>4.1、Nginx<br>请解释什么是C10K问题或者知道什么是C10K问题吗？</p><p>Nginx简介，可参考《Nginx简介》</p><p>正向代理和反向代理.</p><p>Nginx几种常见的负载均衡策略</p><p>Nginx服务器上的Master和Worker进程分别是什么</p><p>使用“反向代理服务器”的优点是什么?</p><p>4.2、分布式其他<br>谈谈业务中使用分布式的场景</p><p>Session 分布式方案</p><p>Session 分布式处理</p><p>分布式锁的应用场景、分布式锁的产生原因、基本概念</p><p>分布是锁的常见解决方案</p><p>分布式事务的常见解决方案</p><p>集群与负载均衡的算法与实现</p><p>说说分库与分表设计，可参考《数据库分库分表策略的具体实现方案》</p><p>分库与分表带来的分布式困境与应对之策</p><p>4.3、Dubbo</p><p>什么是Dubbo，可参考《Dubbo入门》</p><p>什么是RPC、如何实现RPC、RPC 的实现原理，可参考《基于HTTP的RPC实现》</p><p>Dubbo中的SPI是什么概念</p><p>Dubbo的基本原理、执行流程</p><p>五、微服务</p><p>5.1、微服务</p><p>前后端分离是如何做的？</p><p>微服务哪些框架</p><p>Spring Could的常见组件有哪些？可参考《Spring Cloud概述》</p><p>领域驱动有了解吗？什么是领域驱动模型？充血模型、贫血模型</p><p>JWT有了解吗，什么是JWT，可参考《前后端分离利器之JWT》</p><p>你怎么理解 RESTful</p><p>说说如何设计一个良好的 API</p><p>如何理解 RESTful API 的幂等性</p><p>如何保证接口的幂等性</p><p>说说 CAP 定理、BASE 理论</p><p>怎么考虑数据一致性问题</p><p>说说最终一致性的实现方案</p><p>微服务的优缺点，可参考《微服务批判》</p><p>微服务与 SOA 的区别</p><p>如何拆分服务、水平分割、垂直分割</p><p>如何应对微服务的链式调用异常</p><p>如何快速追踪与定位问题</p><p>如何保证微服务的安全、认证</p><p>5.2、安全问题<br>如何防范常见的Web攻击、如何方式SQL注入</p><p>服务端通信安全攻防</p><p>HTTPS原理剖析、降级攻击、HTTP与HTTPS的对比</p><p>5.3、性能优化<br>性能指标有哪些</p><p>如何发现性能瓶颈</p><p>性能调优的常见手段</p><p>说说你在项目中如何进行性能调优</p><p>六、其他<br>6.1、设计能力<br>说说你在项目中使用过的UML图</p><p>你如何考虑组件化、服务化、系统拆分</p><p>秒杀场景如何设计</p><p>可参考：《秒杀系统的技术挑战、应对策略以及架构设计总结一二！》</p><p>6.2、业务工程<br>说说你的开发流程、如何进行自动化部署的</p><p>你和团队是如何沟通的</p><p>你如何进行代码评审</p><p>说说你对技术与业务的理解</p><p>说说你在项目中遇到感觉最难Bug，是如何解决的</p><p>介绍一下工作中的一个你认为最有价值的项目，以及在这个过程中的角色、解决的问题、你觉得你们项目还有哪些不足的地方</p><p>6.3、软实力<br>说说你的优缺点、亮点</p><p>说说你最近在看什么书、什么博客、在研究什么新技术、再看那些开源项目的源代码</p><p>说说你觉得最有意义的技术书籍</p><p>工作之余做什么事情、平时是如何学习的，怎样提升自己的能力</p><p>说说个人发展方向方面的思考</p><p>说说你认为的服务端开发工程师应该具备哪些能力</p><p>说说你认为的架构师是什么样的，架构师主要做什么</p><p>如何看待加班的问题</p><ul><li>zookeeper的watcher乐观锁怎么实现</li><li>一个项目的整个流程</li><li>说出一个空间换时间的场景</li><li>centos7的内存分配方式和6有啥不同</li><li>你对公司有什么价值</li><li>kafka为什么性能这么好</li><li>G1和CMS的区别，G1有啥劣势</li><li>Kafka的整体架构</li><li>Netty的一次请求过程</li><li>自旋锁/偏向锁/轻量级锁</li><li>hbase线上问题排查</li><li>求一棵树两个节点的最近的公共父节点</li><li>HTTP 301 302有啥区别</li><li>设计一个短链接算法</li><li>md5长度是多少</li><li>ThreadLocal如果引用一个static变量是不是线程安全的？</li><li>netty的写流程</li><li>redis数据结构的实现，字符串是怎么实现的，有什么优势</li><li>求一棵树所有左叶子节点的和</li><li>给定一个值K，一个数列，求数列中两个值a和b，使得a+b=k</li><li>kafka的结构</li><li>怎么防止订单重复提交</li><li>缓存同步问题</li><li>istio，介绍了设计理念</li><li>lambda表达式怎么来的，我从lambda演算说到lisp说到scala</li><li>如何保证日志上传的幂等性，如何在保证幂等的前提下提高性能</li><li><strong>问我有没有什么要了解的，花了十几分钟介绍他们现在做的事情、技术栈、未来的一些计划, 项目使用JDK8吗，有使用Stream，Lambda等新特性吗</strong></li><li>如何实现分布式锁、如何保证幂等性、分布式事务的解决方案</li><li>分布式锁的缺点，我说性能会出现瓶颈</li><li>一致性hash如何保证负载均衡</li><li>kafka和rocketmq各自的优缺点</li><li>dubbo的一个请求过程、序列化方式</li><li>序列化框架、PB的缺点、如何从数据库大批量导入数据到hbase</li><li>何保证消息幂等性</li></ul><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://mp.weixin.qq.com/s?__biz=MzA3ODQ0Mzg2OA==&amp;mid=2649047626&amp;idx=1&amp;sn=51772d16d8a09e5bbbd9985acdd8f91c&amp;chksm=87534679b024cf6fef68b47c706f7fd6d977e5621cea478ddf7b64087b7a039eb52eaf748d12&amp;mpshare=1&amp;scene=23&amp;srcid=0510pOnjDH6eemO4NEjdi3RK%23rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzA3ODQ0Mzg2OA==&amp;mid=2649047626&amp;idx=1&amp;sn=51772d16d8a09e5bbbd9985acdd8f91c&amp;chksm=87534679b024cf6fef68b47c706f7fd6d977e5621cea478ddf7b64087b7a039eb52eaf748d12&amp;mpshare=1&amp;scene=23&amp;srcid=0510pOnjDH6eemO4NEjdi3RK%23rd</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&amp;mid=2247484900&amp;idx=1&amp;sn=e3bfb1f5220282bc3578afbb42d2424a&amp;chksm=ebf6dd9bdc81548d6ab47291ca101ce86f936f5bec66edc50f023272d3eb1432bb960c0cee8b&amp;mpshare=1&amp;scene=23&amp;srcid=0530CyFjMU6iegbK9D4aCs9T%23rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&amp;mid=2247484900&amp;idx=1&amp;sn=e3bfb1f5220282bc3578afbb42d2424a&amp;chksm=ebf6dd9bdc81548d6ab47291ca101ce86f936f5bec66edc50f023272d3eb1432bb960c0cee8b&amp;mpshare=1&amp;scene=23&amp;srcid=0530CyFjMU6iegbK9D4aCs9T%23rd</a></p>]]></content>
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>线程的生命周期，状态是如何转移的</title>
      <link href="/2018/05/10/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%8C%E7%8A%B6%E6%80%81%E6%98%AF%E5%A6%82%E4%BD%95%E8%BD%AC%E7%A7%BB%E7%9A%84/"/>
      <url>/2018/05/10/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%8C%E7%8A%B6%E6%80%81%E6%98%AF%E5%A6%82%E4%BD%95%E8%BD%AC%E7%A7%BB%E7%9A%84/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>线程池的几种实现方式</title>
      <link href="/2018/05/10/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"/>
      <url>/2018/05/10/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>讲讲线程池的实现原理</title>
      <link href="/2018/05/10/%E8%AE%B2%E8%AE%B2%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>/2018/05/10/%E8%AE%B2%E8%AE%B2%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>ThreadLocal 原理分析，ThreadLocal为什么会出现OOM，出现的深层次原理</title>
      <link href="/2018/05/10/ThreadLocal-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%EF%BC%8CThreadLocal%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0OOM%EF%BC%8C%E5%87%BA%E7%8E%B0%E7%9A%84%E6%B7%B1%E5%B1%82%E6%AC%A1%E5%8E%9F%E7%90%86/"/>
      <url>/2018/05/10/ThreadLocal-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%EF%BC%8CThreadLocal%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0OOM%EF%BC%8C%E5%87%BA%E7%8E%B0%E7%9A%84%E6%B7%B1%E5%B1%82%E6%AC%A1%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>说说 Exchanger 原理</title>
      <link href="/2018/05/10/%E8%AF%B4%E8%AF%B4-Exchanger-%E5%8E%9F%E7%90%86/"/>
      <url>/2018/05/10/%E8%AF%B4%E8%AF%B4-Exchanger-%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>说说 Semaphore 原理</title>
      <link href="/2018/05/10/%E8%AF%B4%E8%AF%B4-Semaphore-%E5%8E%9F%E7%90%86/"/>
      <url>/2018/05/10/%E8%AF%B4%E8%AF%B4-Semaphore-%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>说说 CountDownLatch、CyclicBarrier 原理和区别</title>
      <link href="/2018/05/10/%E8%AF%B4%E8%AF%B4-CountDownLatch%E3%80%81CyclicBarrier-%E5%8E%9F%E7%90%86%E5%92%8C%E5%8C%BA%E5%88%AB/"/>
      <url>/2018/05/10/%E8%AF%B4%E8%AF%B4-CountDownLatch%E3%80%81CyclicBarrier-%E5%8E%9F%E7%90%86%E5%92%8C%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>进程间通信的方式</title>
      <link href="/2018/05/10/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
      <url>/2018/05/10/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>创建线程的方式及实现</title>
      <link href="/2018/05/10/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/05/10/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>线程和进程的概念、并行和并发的概念</title>
      <link href="/2018/05/10/%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5%E3%80%81%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91%E7%9A%84%E6%A6%82%E5%BF%B5/"/>
      <url>/2018/05/10/%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5%E3%80%81%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91%E7%9A%84%E6%A6%82%E5%BF%B5/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>手写简单的HashMap</title>
      <link href="/2018/05/10/%E6%89%8B%E5%86%99%E7%AE%80%E5%8D%95%E7%9A%84HashMap/"/>
      <url>/2018/05/10/%E6%89%8B%E5%86%99%E7%AE%80%E5%8D%95%E7%9A%84HashMap/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>ConcurrentHashMap 的工作原理及代码实现，如何统计所有的元素个数</title>
      <link href="/2018/05/10/ConcurrentHashMap-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%8C%E5%A6%82%E4%BD%95%E7%BB%9F%E8%AE%A1%E6%89%80%E6%9C%89%E7%9A%84%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0/"/>
      <url>/2018/05/10/ConcurrentHashMap-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%8C%E5%A6%82%E4%BD%95%E7%BB%9F%E8%AE%A1%E6%89%80%E6%9C%89%E7%9A%84%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ol><li>ConcurrentHashMap在JDK7和JDK8中有什么不同？</li><li><p>简述</p><a id="more"></a></li><li></li></ol><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1>]]></content>
      
      
    </entry>
    
    <entry>
      <title>HashMap出现Hash DOS攻击的问题</title>
      <link href="/2018/05/10/HashMap%E5%87%BA%E7%8E%B0Hash-DOS%E6%94%BB%E5%87%BB%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2018/05/10/HashMap%E5%87%BA%E7%8E%B0Hash-DOS%E6%94%BB%E5%87%BB%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>多线程情况下HashMap死循环的问题</title>
      <link href="/2018/05/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%83%85%E5%86%B5%E4%B8%8BHashMap%E6%AD%BB%E5%BE%AA%E7%8E%AF%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2018/05/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%83%85%E5%86%B5%E4%B8%8BHashMap%E6%AD%BB%E5%BE%AA%E7%8E%AF%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>HashMap 的工作原理及代码实现，什么时候用到红黑树</title>
      <link href="/2018/05/10/HashMap-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E5%88%B0%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
      <url>/2018/05/10/HashMap-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E5%88%B0%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>HashMap 和 ConcurrentHashMap 的区别</title>
      <link href="/2018/05/10/HashMap-%E5%92%8C-ConcurrentHashMap-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2018/05/10/HashMap-%E5%92%8C-ConcurrentHashMap-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>HashSet 和 HashMap 区别</title>
      <link href="/2018/05/10/HashSet-%E5%92%8C-HashMap-%E5%8C%BA%E5%88%AB/"/>
      <url>/2018/05/10/HashSet-%E5%92%8C-HashMap-%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>HashMap 和 Hashtable 的区别</title>
      <link href="/2018/05/10/HashMap-%E5%92%8C-Hashtable-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2018/05/10/HashMap-%E5%92%8C-Hashtable-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>ArrayList 与 Vector 区别</title>
      <link href="/2018/05/10/ArrayList-%E4%B8%8E-Vector-%E5%8C%BA%E5%88%AB/"/>
      <url>/2018/05/10/ArrayList-%E4%B8%8E-Vector-%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>Arraylist 与 LinkedList 区别</title>
      <link href="/2018/05/10/Arraylist-%E4%B8%8E-LinkedList-%E5%8C%BA%E5%88%AB/"/>
      <url>/2018/05/10/Arraylist-%E4%B8%8E-LinkedList-%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>List 和 Map 区别</title>
      <link href="/2018/05/10/List-%E5%92%8C-Map-%E5%8C%BA%E5%88%AB/"/>
      <url>/2018/05/10/List-%E5%92%8C-Map-%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>Set和hashCode以及equals方法的联系</title>
      <link href="/2018/05/10/Set%E5%92%8ChashCode%E4%BB%A5%E5%8F%8Aequals%E6%96%B9%E6%B3%95%E7%9A%84%E8%81%94%E7%B3%BB/"/>
      <url>/2018/05/10/Set%E5%92%8ChashCode%E4%BB%A5%E5%8F%8Aequals%E6%96%B9%E6%B3%95%E7%9A%84%E8%81%94%E7%B3%BB/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>List 和 Set 区别</title>
      <link href="/2018/05/10/List-%E5%92%8C-Set-%E5%8C%BA%E5%88%AB/"/>
      <url>/2018/05/10/List-%E5%92%8C-Set-%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> JDK </category>
          
          <category> Set </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Set </tag>
            
            <tag> HashSet </tag>
            
            <tag> TreeSet </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java 8有哪些新特性</title>
      <link href="/2018/05/10/Java-8%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2018/05/10/Java-8%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>JDK和JRE的区别</title>
      <link href="/2018/05/10/JDK%E5%92%8CJRE%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2018/05/10/JDK%E5%92%8CJRE%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>Java的平台无关性如何体现出来的</title>
      <link href="/2018/05/10/Java%E7%9A%84%E5%B9%B3%E5%8F%B0%E6%97%A0%E5%85%B3%E6%80%A7%E5%A6%82%E4%BD%95%E4%BD%93%E7%8E%B0%E5%87%BA%E6%9D%A5%E7%9A%84/"/>
      <url>/2018/05/10/Java%E7%9A%84%E5%B9%B3%E5%8F%B0%E6%97%A0%E5%85%B3%E6%80%A7%E5%A6%82%E4%BD%95%E4%BD%93%E7%8E%B0%E5%87%BA%E6%9D%A5%E7%9A%84/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>Object类中常见的方法，为什么wait  notify会放在Object里边？</title>
      <link href="/2018/05/10/Object%E7%B1%BB%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88wait-notify%E4%BC%9A%E6%94%BE%E5%9C%A8Object%E9%87%8C%E8%BE%B9%EF%BC%9F/"/>
      <url>/2018/05/10/Object%E7%B1%BB%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88wait-notify%E4%BC%9A%E6%94%BE%E5%9C%A8Object%E9%87%8C%E8%BE%B9%EF%BC%9F/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>什么是Java序列化和反序列化，如何实现Java序列化？或者请解释Serializable 接口的作用</title>
      <link href="/2018/05/10/%E4%BB%80%E4%B9%88%E6%98%AFJava%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0Java%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9F%E6%88%96%E8%80%85%E8%AF%B7%E8%A7%A3%E9%87%8ASerializable-%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
      <url>/2018/05/10/%E4%BB%80%E4%B9%88%E6%98%AFJava%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0Java%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9F%E6%88%96%E8%80%85%E8%AF%B7%E8%A7%A3%E9%87%8ASerializable-%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>hashCode和equals方法的区别与联系</title>
      <link href="/2018/05/10/hashCode%E5%92%8Cequals%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB/"/>
      <url>/2018/05/10/hashCode%E5%92%8Cequals%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>equals与==的区别</title>
      <link href="/2018/05/10/equals%E4%B8%8E-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2018/05/10/equals%E4%B8%8E-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>MVC设计思想</title>
      <link href="/2018/05/10/MVC%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/"/>
      <url>/2018/05/10/MVC%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>列出自己常用的JDK包</title>
      <link href="/2018/05/10/%E5%88%97%E5%87%BA%E8%87%AA%E5%B7%B1%E5%B8%B8%E7%94%A8%E7%9A%84JDK%E5%8C%85/"/>
      <url>/2018/05/10/%E5%88%97%E5%87%BA%E8%87%AA%E5%B7%B1%E5%B8%B8%E7%94%A8%E7%9A%84JDK%E5%8C%85/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>Session与Cookie区别</title>
      <link href="/2018/05/10/Session%E4%B8%8ECookie%E5%8C%BA%E5%88%AB/"/>
      <url>/2018/05/10/Session%E4%B8%8ECookie%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>HTTP请求的GET与POST方式的区别</title>
      <link href="/2018/05/10/HTTP%E8%AF%B7%E6%B1%82%E7%9A%84GET%E4%B8%8EPOST%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2018/05/10/HTTP%E8%AF%B7%E6%B1%82%E7%9A%84GET%E4%B8%8EPOST%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>说说自定义注解的场景及实现</title>
      <link href="/2018/05/10/%E8%AF%B4%E8%AF%B4%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%9C%BA%E6%99%AF%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/05/10/%E8%AF%B4%E8%AF%B4%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%9C%BA%E6%99%AF%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul><li>Java注解基本知识</li><li>如何访问注解<a id="more"></a></li></ul><h1 id="Java注解基本知识"><a href="#Java注解基本知识" class="headerlink" title="Java注解基本知识"></a>Java注解基本知识</h1><ul><li>注解是代码的附属信息，不能干扰代码的正常执行，无论删除或增加注解，代码都能够正常执行</li><li>定义注解使用@interface修饰符</li><li>Java预定义注解被称为元注解，它们被Java编译器使用，比如：@Retention注解和@Target注解，前者定义注解的保留期限，后者定义注解的应用目标</li><li>注解的成员声明和接口的方法声明类似，还可以使用default关键字指定成员的默认值</li><li>如果注解只有一个成员，则成员名必须取名为<code>value()</code>,使用时如果给成员赋值可以不写成员名和赋值符号’=’</li><li>如果注解有多个成员，在赋值时如果只给<code>value()</code>成员赋值，也可以不写成员名和赋值符号’=’</li><li>如果在赋值时要同时给多个成员赋值，则必须写成员名和赋值符号’=’</li><li>所有注解类都隐式继承与<code>java.lang.annotation.Annotation</code>,但是注解不允许显示继承于其他的接口</li></ul><p><strong>有个问题，Java中所有类都隐式继承与Object类这个说法正确吗？</strong></p><h1 id="如何访问注解"><a href="#如何访问注解" class="headerlink" title="如何访问注解"></a>如何访问注解</h1><p>通过Java的反射机制读取注解的信息<br>若要通过反射来读取注解信息，那么被定义的注解的保留期限必须是RententionPolicy.RUNTIME,<br>只有该策略下的注解信息会被保留在目标类代码的字节码中，并且当类加载器加载字节码时会将注解信息加载到JVM中</p><h2 id="定义注解"><a href="#定义注解" class="headerlink" title="定义注解"></a>定义注解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME) <span class="comment">// 定义@NeedTest注解的保留期限，该注解会保存到目标类的字节码中，并且会被类加载器加载到JVM中</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD) <span class="comment">// 定义@NeedTest注解的应用目标，这是一个方法级别的注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> NeedTest &#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>; <span class="comment">// 单个成员，成员名必须是value(), 默认值是true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saySomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"say something"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NeedTest</span>(<span class="keyword">true</span>) <span class="comment">// 成员名value()设置为true</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello "</span>+ name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NeedTest</span>(<span class="keyword">false</span>) <span class="comment">// 成员名value()设置为false</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hi "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="访问注解"><a href="#访问注解" class="headerlink" title="访问注解"></a>访问注解</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCustomAnnotation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Class clazz = MyService.class;</span><br><span class="line">    Method[] methods = clazz.getDeclaredMethods();</span><br><span class="line">    <span class="keyword">if</span> (methods.length == <span class="number">0</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">"method "</span> + clazz.getName() + <span class="string">" has no declared method"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods)&#123;</span><br><span class="line">            NeedTest annotation = method.getAnnotation(NeedTest.class); <span class="comment">// 所有自定义的注解都隐式继承自java.lang.annotation.Annotation接口，但是不允许显示继承其他接口</span></span><br><span class="line">            <span class="keyword">if</span> (annotation == <span class="keyword">null</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"method"</span> + method.getName() + <span class="string">" has not annotated @NeedTest"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">boolean</span> value = annotation.value();</span><br><span class="line">                System.out.println(method.getName() + <span class="string">" has annotated @NeedTest and value = "</span> + value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p>《精通Spring4.x——企业应用开发实践》 第8章 基于@AspectJ和Schema的AOP 8.2 Java5.0注解知识快速进阶</p>]]></content>
      
      <categories>
          
          <category> JDK </category>
          
          <category> Annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Annotation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>说说反射的用途及实现</title>
      <link href="/2018/05/10/%E8%AF%B4%E8%AF%B4%E5%8F%8D%E5%B0%84%E7%9A%84%E7%94%A8%E9%80%94%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/05/10/%E8%AF%B4%E8%AF%B4%E5%8F%8D%E5%B0%84%E7%9A%84%E7%94%A8%E9%80%94%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>抽象类和接口有什么区别</title>
      <link href="/2018/05/10/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/"/>
      <url>/2018/05/10/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>重载和重写的区别</title>
      <link href="/2018/05/10/%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2018/05/10/%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>String、StringBuilder、StringBuffer</title>
      <link href="/2018/05/10/String%E3%80%81StringBuilder%E3%80%81StringBuffer/"/>
      <url>/2018/05/10/String%E3%80%81StringBuilder%E3%80%81StringBuffer/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>包装类，装箱和拆箱</title>
      <link href="/2018/05/10/%E5%8C%85%E8%A3%85%E7%B1%BB%EF%BC%8C%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1/"/>
      <url>/2018/05/10/%E5%8C%85%E8%A3%85%E7%B1%BB%EF%BC%8C%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>int 和 Integer 有什么区别，Integer的值缓存范围</title>
      <link href="/2018/05/10/int-%E5%92%8C-Integer-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%8CInteger%E7%9A%84%E5%80%BC%E7%BC%93%E5%AD%98%E8%8C%83%E5%9B%B4/"/>
      <url>/2018/05/10/int-%E5%92%8C-Integer-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%8CInteger%E7%9A%84%E5%80%BC%E7%BC%93%E5%AD%98%E8%8C%83%E5%9B%B4/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>请写出5种常见到的runtime exception</title>
      <link href="/2018/05/10/%E8%AF%B7%E5%86%99%E5%87%BA5%E7%A7%8D%E5%B8%B8%E8%A7%81%E5%88%B0%E7%9A%84runtime-exception/"/>
      <url>/2018/05/10/%E8%AF%B7%E5%86%99%E5%87%BA5%E7%A7%8D%E5%B8%B8%E8%A7%81%E5%88%B0%E7%9A%84runtime-exception/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>Exception、Error、运行时异常与一般异常有何异同</title>
      <link href="/2018/05/10/Exception%E3%80%81Error%E3%80%81%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8%E4%B8%8E%E4%B8%80%E8%88%AC%E5%BC%82%E5%B8%B8%E6%9C%89%E4%BD%95%E5%BC%82%E5%90%8C/"/>
      <url>/2018/05/10/Exception%E3%80%81Error%E3%80%81%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8%E4%B8%8E%E4%B8%80%E8%88%AC%E5%BC%82%E5%B8%B8%E6%9C%89%E4%BD%95%E5%BC%82%E5%90%8C/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>final, finally, finalize 的区别</title>
      <link href="/2018/05/10/final-finally-finalize-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2018/05/10/final-finally-finalize-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>WebApplicationContext与ServletContext的相关问题</title>
      <link href="/2018/05/10/WebApplicationContext%E4%B8%8EServletContext%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
      <url>/2018/05/10/WebApplicationContext%E4%B8%8EServletContext%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h1 id="ContextLoaderListener类图"><a href="#ContextLoaderListener类图" class="headerlink" title="ContextLoaderListener类图"></a>ContextLoaderListener类图</h1><p><img src="http://g.gravizo.com/svg?abstract class org.springframework.web.context.ContextLoader &lt;|-- class ContextLoaderListener;interface javax.servlet.ServletContextListener &lt;|.. ContextLoaderListener;interface java.util.EventListener &lt;|-- javax.servlet.ServletContextListener;;" alt="ContextLoaderListener类图"></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1>]]></content>
      
      <categories>
          
          <category> Spring </category>
          
          <category> WebMVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ApplicationContext </tag>
            
            <tag> ServletContext </tag>
            
            <tag> Spring </tag>
            
            <tag> Servlet </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MyBatis缓存的相关问题</title>
      <link href="/2018/05/10/MyBatis%E7%BC%93%E5%AD%98%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
      <url>/2018/05/10/MyBatis%E7%BC%93%E5%AD%98%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul><li>MyBatis一级缓存和二级缓存的实现原理是什么？</li><li>MyBatis二级缓存的实现方式有哪些，默认使用什么方式？</li><li>MyBatis缓存最佳实践</li></ul><a id="more"></a><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>一级缓存是sqlsession级别，MyBatis默认开启一级缓存，</p><p>二级缓存是Mapper级别，默认是关闭的。</p><!-- ![d](images/test.jpg) --><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.cnblogs.com/fqwsndc1314-5207788/p/7594924.html" target="_blank" rel="noopener">https://www.cnblogs.com/fqwsndc1314-5207788/p/7594924.html</a></p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
          <category> MyBatis </category>
          
          <category> Cache </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Mybatis </tag>
            
            <tag> Cache </tag>
            
            <tag> 缓存 </tag>
            
            <tag> 一级缓存 </tag>
            
            <tag> 二级缓存 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>并发与多线程</title>
      <link href="/2018/05/09/%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2018/05/09/%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul><li>什么是并发，与并行的区别</li><li>为什么要用到并发</li><li>并发编程最佳实践</li></ul><h1 id="什么是并发，与并行的区别"><a href="#什么是并发，与并行的区别" class="headerlink" title="什么是并发，与并行的区别"></a>什么是并发，与并行的区别</h1><p>在计算机程序世界中，并发指的是计算机可以执行多个任务的能力；而并行指计算机能<strong>同时</strong>处理多个任务，它们的最关键点是<strong>同时</strong>。</p><h1 id="为什么要用到并发"><a href="#为什么要用到并发" class="headerlink" title="为什么要用到并发"></a>为什么要用到并发</h1><p>多核的CPU的背景下，催生了并发编程的趋势，并发编程的形式可以将多核CPU的计算能力发挥到极致，提高程序的性能</p><h1 id="并发编程最佳实践"><a href="#并发编程最佳实践" class="headerlink" title="并发编程最佳实践"></a>并发编程最佳实践</h1><p>先说说并发编程哪些缺点，或者说要注意些什么：</p><h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p>时间片是CPU分配给各个线程的时间，因为时间非常短，所以CPU不断通过切换线程，让我们觉得多个线程是同时执行的，时间片一般是几十毫秒。</p><p>如果多个线程在并发执行任务的时候频繁地切换上下文，将无法发挥并发编程的优势，因为上下文的切换要保存当前状态，以便能够恢复先前状态，而上线文切换又非常损耗性能。</p><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><ol><li>多线程编程中最难以把握的就是临界区线程安全问题，稍微不注意就会出现死锁的情况，一旦产生死锁就会造成系统功能不可用。</li><li>如何保证线程安全</li><li>如何正确理解由于JMM内存模型在原子性，有序性，可见性带来的问题<ol><li>数据脏读</li><li>DCL双重检车加锁</li></ol></li></ol><h3 id="DCL双重检车加锁"><a href="#DCL双重检车加锁" class="headerlink" title="DCL双重检车加锁"></a>DCL双重检车加锁</h3><p>DCL双重检车加锁的真正问题在于：当没有同步的情况下读取一个共享对象时，读到的可能是一个尚未创建完成的对象，可能是一个失效的值。<br>为什么要第二次判断呢？<br>原因是当多个线程都经过了第一次判空之后，如果锁内不判空，就会导致实例被重复创建</p><p>对于可变对象必须通过安全的方式来发布，这通常意味着在发布和使用该对象时都必须使用同步，我们可以使用一下的方式来安全地发布对象：</p><ol><li><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1></li></ol><p><a href="https://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&amp;mid=2247485326&amp;idx=1&amp;sn=62ef70c9baac6ccaec385b519cdbdb6c&amp;chksm=ebd638a2dca1b1b4bc38d6add52c26d0c8d96021fcf0eae18a911abbb32c6b2d33b2af177d60&amp;mpshare=1&amp;scene=23&amp;srcid=0509oLVaS1l1ByXNHBg7zUI1%23rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&amp;mid=2247485326&amp;idx=1&amp;sn=62ef70c9baac6ccaec385b519cdbdb6c&amp;chksm=ebd638a2dca1b1b4bc38d6add52c26d0c8d96021fcf0eae18a911abbb32c6b2d33b2af177d60&amp;mpshare=1&amp;scene=23&amp;srcid=0509oLVaS1l1ByXNHBg7zUI1%23rd</a></p><p>《Java并发编程实战》3.5.3，16.2.4</p>]]></content>
      
      <categories>
          
          <category> JDK </category>
          
          <category> Concurrent </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Thread </tag>
            
            <tag> Concurrent </tag>
            
            <tag> 并发 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java线程池相关问题</title>
      <link href="/2018/05/08/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
      <url>/2018/05/08/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在任务队列长度有限的情况下就会出现新任务的拒绝处理问题，需要有一种策略来处理应该加入任务队列却因为队列已满无法加入的情况；在线程池关闭的时候也需要对任务加入队列操作进行额外的协调处理<br><a id="more"></a></p><h1 id="Java线程池任务拒绝策略"><a href="#Java线程池任务拒绝策略" class="headerlink" title="Java线程池任务拒绝策略"></a>Java线程池任务拒绝策略</h1><p>RejectedExecutionHandler提供了四种方式来处理任务拒绝策略</p><ol><li>直接丢弃（DiscardPolicy）</li><li>丢弃队列中最老的任务(DiscardOldestPolicy)。</li><li>抛异常(AbortPolicy)</li><li>将任务分给调用线程来执行(CallerRunsPolicy)。</li></ol><h1 id="ExecutorService类图"><a href="#ExecutorService类图" class="headerlink" title="ExecutorService类图"></a>ExecutorService类图</h1><p><img src="http://g.gravizo.com/svg?interface java.util.concurrent.Executor &lt;|-- interface java.util.concurrent.ExecutorService;" alt="ExecutorService类图"></p><h1 id="ThreadPoolExecutor类图"><a href="#ThreadPoolExecutor类图" class="headerlink" title="ThreadPoolExecutor类图"></a>ThreadPoolExecutor类图</h1><p><img src="http://g.gravizo.com/svg?abstract java.util.concurrent.AbstractExecutorService &lt;|-- java.util.concurrent.ThreadPoolExecutor; interface java.util.concurrent.ExecutorService &lt;|.. abstract java.util.concurrent.AbstractExecutorService; interface java.util.concurrent.Executor &lt;|-- interface java.util.concurrent.ExecutorService;" alt="ThreadPoolExecutor类图"></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://blog.csdn.net/u010412719/article/details/52132613" target="_blank" rel="noopener">https://blog.csdn.net/u010412719/article/details/52132613</a></p><p><a href="http://www.importnew.com/19011.html" target="_blank" rel="noopener">http://www.importnew.com/19011.html</a></p><p><a href="http://www.importnew.com/27305.html" target="_blank" rel="noopener">http://www.importnew.com/27305.html</a></p><p><a href="https://www.cnblogs.com/dolphin0520/p/3949310.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3949310.html</a></p>]]></content>
      
      <categories>
          
          <category> JDK </category>
          
          <category> ThreadPool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Thread </tag>
            
            <tag> ThreadPool </tag>
            
            <tag> Executer </tag>
            
            <tag> ExecuterService </tag>
            
            <tag> BlockingQueue </tag>
            
            <tag> 任务拒绝策略 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ActiveMQ相关问题</title>
      <link href="/2018/05/08/ActiveMQ%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
      <url>/2018/05/08/ActiveMQ%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><a id="more"></a><h1 id="消息传递方式"><a href="#消息传递方式" class="headerlink" title="消息传递方式"></a>消息传递方式</h1><h2 id="P2P点对点"><a href="#P2P点对点" class="headerlink" title="P2P点对点"></a>P2P点对点</h2><ul><li>消息可以被同步或异步的发送和接收，每个消息只会给一个 Consumer 传送一次</li><li>多个 Consumer 可以注册到同一个 queue 上，但一个消息只能被一个 Consumer 所接收</li></ul><h3 id="P2P模式下，queue的大小默认是多少，可以调整吗？"><a href="#P2P模式下，queue的大小默认是多少，可以调整吗？" class="headerlink" title="P2P模式下，queue的大小默认是多少，可以调整吗？"></a>P2P模式下，queue的大小默认是多少，可以调整吗？</h3><h2 id="Pub-Sub-发布-订阅"><a href="#Pub-Sub-发布-订阅" class="headerlink" title="Pub/Sub 发布/订阅"></a>Pub/Sub 发布/订阅</h2><ul><li>除非显式指定，否则 topic 不会为订阅者保留消息</li><li>持久化订阅者重新连接</li><li>(对于Topic而言，一条消息只有所有的订阅者都消费才会被删除</li></ul><h1 id="ActiveMQ优化"><a href="#ActiveMQ优化" class="headerlink" title="ActiveMQ优化"></a>ActiveMQ优化</h1><h1 id="GitHub地址"><a href="#GitHub地址" class="headerlink" title="GitHub地址"></a>GitHub地址</h1><p><a href="https://github.com/scutuyu/activemq.git" target="_blank" rel="noopener">源码地址</a></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://mp.weixin.qq.com/s?__biz=MzA3ODQ0Mzg2OA==&amp;mid=2649047618&amp;idx=1&amp;sn=f14a50c42f07e263a4e8c3eef0543e6b&amp;chksm=87534671b024cf67dcea059f2fddbe408c1cf56b1687e18c3f2f9aec15a34284c2d38de67c8d&amp;mpshare=1&amp;scene=23&amp;srcid=0508MUi5BoS2wAQvewIzzOdp%23rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzA3ODQ0Mzg2OA==&amp;mid=2649047618&amp;idx=1&amp;sn=f14a50c42f07e263a4e8c3eef0543e6b&amp;chksm=87534671b024cf67dcea059f2fddbe408c1cf56b1687e18c3f2f9aec15a34284c2d38de67c8d&amp;mpshare=1&amp;scene=23&amp;srcid=0508MUi5BoS2wAQvewIzzOdp%23rd</a></p><p><a href="https://blog.csdn.net/java20150326/article/details/72084657" target="_blank" rel="noopener">https://blog.csdn.net/java20150326/article/details/72084657</a><br><a href="https://blog.csdn.net/u012758088/article/details/78046108" target="_blank" rel="noopener">https://blog.csdn.net/u012758088/article/details/78046108</a><br><a href="http://shift-alt-ctrl.iteye.com/blog/2061859" target="_blank" rel="noopener">http://shift-alt-ctrl.iteye.com/blog/2061859</a></p>]]></content>
      
      <categories>
          
          <category> JMS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JMS </tag>
            
            <tag> ActiveMQ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>八皇后问题</title>
      <link href="/2018/05/08/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/"/>
      <url>/2018/05/08/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul><li>什么是八皇后问题？</li><li>八皇后问题的难点是什么？</li><li>如何实现？-源码</li></ul><a id="more"></a><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>如何能够在8×8的国际象棋棋盘上放置八个皇后，使得任何一个皇后都无法直接吃掉其他的皇后？为了达到此目的，任两个皇后都不能处于同一条横行、纵行或斜线上</p><h1 id="难点有哪些"><a href="#难点有哪些" class="headerlink" title="难点有哪些"></a>难点有哪些</h1><h2 id="递归回溯法"><a href="#递归回溯法" class="headerlink" title="递归回溯法"></a>递归回溯法</h2><blockquote><p>所谓递归回溯，本质上是一种枚举法。这种方法从棋盘的第一行开始尝试摆放第一个皇后，摆放成功后，递归一层，再遵循规则在棋盘第二行来摆放第二个皇后。如果当前位置无法摆放，则向右移动一格再次尝试，如果摆放成功，则继续递归一层，摆放第三个皇后……</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">settleQueen</span><span class="params">(<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r == row)&#123; <span class="comment">// 为最后一行设置Queen时返回true，因为这行的结果不会影响其他的行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; col; index++)&#123; <span class="comment">// 从第一列遍历到最后一列</span></span><br><span class="line">        <span class="comment">// 当前行元素都清零,为回溯做铺垫</span></span><br><span class="line">        clearRow(r);</span><br><span class="line">        <span class="keyword">if</span> (check(r, index))&#123;</span><br><span class="line">            chess[r][index] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (settleQueen(r + <span class="number">1</span>))&#123;<span class="comment">// 递归,如果返回false则回溯</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何判断某个格子的斜线上是否已经存在Queen"><a href="#如何判断某个格子的斜线上是否已经存在Queen" class="headerlink" title="如何判断某个格子的斜线上是否已经存在Queen"></a>如何判断某个格子的斜线上是否已经存在Queen</h2><blockquote><p>同一条斜线上的元素的索引的和相等,或者同一条斜线上的元素的索引的差相等</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = i + j; <span class="comment">// 同一条斜线上的元素的索引的和相等</span></span><br><span class="line">    <span class="keyword">int</span> sub = i - j; <span class="comment">// 或者 同一条斜线上的元素的索引的差相等</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> m = sum &gt;= row ? row - <span class="number">1</span> : sum; m &gt;= <span class="number">0</span> &amp;&amp; sum - m &lt; col; m--)&#123;</span><br><span class="line">         <span class="keyword">if</span> (chess[m][sum - m] == <span class="number">1</span>)&#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> m = sub &lt;= <span class="number">0</span> ? <span class="number">0</span> : sub; m &lt; row &amp;&amp; m - sub &lt; row; m++)&#123;</span><br><span class="line">         <span class="keyword">if</span> (chess[m][m - sub] == <span class="number">1</span>)&#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; row; m++)&#123;</span><br><span class="line">         <span class="keyword">if</span> (chess[m][j] == <span class="number">1</span>)&#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="GitHub地址"><a href="#GitHub地址" class="headerlink" title="GitHub地址"></a>GitHub地址</h2><p><a href="https://github.com/scutuyu/algorithm/blob/master/src/main/java/com/tuyu/EightQueen.java" target="_blank" rel="noopener">源码地址</a></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;mid=2653193309&amp;idx=1&amp;sn=dd68a60873bb360e02afde21acde7d3f&amp;chksm=8c99f687bbee7f91049c253dd3193c9a60d6d98cd315b0140a8635b2d34933b54a19127921a9&amp;mpshare=1&amp;scene=23&amp;srcid=0508U4Oiadttnnqx96Es30nZ%23rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;mid=2653193309&amp;idx=1&amp;sn=dd68a60873bb360e02afde21acde7d3f&amp;chksm=8c99f687bbee7f91049c253dd3193c9a60d6d98cd315b0140a8635b2d34933b54a19127921a9&amp;mpshare=1&amp;scene=23&amp;srcid=0508U4Oiadttnnqx96Es30nZ%23rd</a></p><p><a href="https://blog.csdn.net/friendan/article/details/8809089" target="_blank" rel="noopener">https://blog.csdn.net/friendan/article/details/8809089</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>RPC与RMI的区别</title>
      <link href="/2018/05/07/RPC%E4%B8%8ERMI%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2018/05/07/RPC%E4%B8%8ERMI%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><a id="more"></a><p>使用J<a href="https://github.com/scutuyu/rmi" target="_blank" rel="noopener">DK原生RMI框架</a></p><h1 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h1><p><a href="https://blog.csdn.net/xiaominthere/article/details/46501505" target="_blank" rel="noopener">https://blog.csdn.net/xiaominthere/article/details/46501505</a><br><a href="https://blog.csdn.net/shan9liang/article/details/8995023" target="_blank" rel="noopener">https://blog.csdn.net/shan9liang/article/details/8995023</a></p>]]></content>
      
      <categories>
          
          <category> RPC </category>
          
          <category> RMI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RPC </tag>
            
            <tag> RMI </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Dubbo框架常见问题</title>
      <link href="/2018/05/07/Dubbo%E6%A1%86%E6%9E%B6%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
      <url>/2018/05/07/Dubbo%E6%A1%86%E6%9E%B6%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><a id="more"></a><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="默认使用的是什么通信框架，还有别的选择吗"><a href="#默认使用的是什么通信框架，还有别的选择吗" class="headerlink" title="默认使用的是什么通信框架，还有别的选择吗?"></a>默认使用的是什么通信框架，还有别的选择吗?</h2><p><strong>答：</strong> Dubbo默认使用Dubbo协议，而Dubbo协议使用基于mina + hessian的tbremoting交互；除此之外Dubbo还可以选择:</p><ol><li>采用JDK标准的java.rmi.*实现的rmi协议，它采用阻塞式短连接和JDK标准序列化方式</li><li>hessian协议，底层采用HTTP通信，采用Servlet暴露服务，默认内嵌Jetty作为服务器实现</li><li>基于HTTP表单的远程调用协议，采用Spring的HttpInvoker实现</li><li>基于webservice的远程调用协议，基于Apache CXF的fronted-simple和transports-http、基于原生thrift协议的扩展，比如协议头添加额外字段</li><li>基于memcached实现的RPC协议</li><li>基于Redis实现的RPC协议</li></ol><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><blockquote><footer><strong>Dubbo用户手册（中文）</strong><cite><a href="http://dubbo.apache.org/books/dubbo-user-book/best-practice.html" target="_blank" rel="noopener">9 协议参考手册</a></cite></footer></blockquote><blockquote><footer><strong>ALIBABA DUBBO框架同步调用原理分析</strong><cite><a href="http://www.blogjava.net/xiaomage234/archive/2014/05/09/413465.html" target="_blank" rel="noopener">www.blogjava.net/xiaomage234/archive/2014/05/09/413465.html</a></cite></footer></blockquote>]]></content>
      
      <categories>
          
          <category> Dubbo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RPC </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于ArrayList、LinkedList序列化问题</title>
      <link href="/2018/05/04/%E5%85%B3%E4%BA%8EArrayList%E3%80%81LinkedList%E5%BA%8F%E5%88%97%E5%8C%96%E9%97%AE%E9%A2%98/"/>
      <url>/2018/05/04/%E5%85%B3%E4%BA%8EArrayList%E3%80%81LinkedList%E5%BA%8F%E5%88%97%E5%8C%96%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<blockquote><p>在序列化过程中，虚拟机会试图调用对象类里的 writeObject 和 readObject 方法，进行用户自定义的序列化和反序列化，如果没有这样的方法，则默认调用&gt; 是 ObjectOutputStream 的 defaultWriteObject 方法以及 ObjectInputStream 的 defaultReadObject 方法。用户自定义的 writeObject &gt; &gt; 和 readObject 方法可以允许用户控制序列化的过程，比如可以在序列化的过程中动态改变序列化的数值。基于这个原理，可以在实际应用中得到使用，用于敏感&gt; 字段的加密工作，清单 3 展示了这个过程。</p></blockquote><a id="more"></a><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-serial/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-serial/index.html</a><br><a href="https://blog.csdn.net/qfycc92/article/details/45370011" target="_blank" rel="noopener">https://blog.csdn.net/qfycc92/article/details/45370011</a><br><a href="https://blog.csdn.net/u014634338/article/details/78165127" target="_blank" rel="noopener">https://blog.csdn.net/u014634338/article/details/78165127</a></p>]]></content>
      
      <categories>
          
          <category> JDK </category>
          
          <category> Collections </category>
          
          <category> List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> List </tag>
            
            <tag> ArrayList </tag>
            
            <tag> LinkedList </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>多道程序设计、进程、线程</title>
      <link href="/2018/05/03/%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%81%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B/"/>
      <url>/2018/05/03/%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%81%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><ol><li>什么是多道程序设计？ </li><li>什么是进程？</li><li>什么是线程？</li><li>为什么要使用多线程而不是多进程？</li></ol><a id="more"></a><a>text ../hello-world</a><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1>]]></content>
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>markdown+gravizo画UML类图</title>
      <link href="/2018/04/28/markdown-gravizo%E7%94%BBUML%E7%B1%BB%E5%9B%BE/"/>
      <url>/2018/04/28/markdown-gravizo%E7%94%BBUML%E7%B1%BB%E5%9B%BE/</url>
      <content type="html"><![CDATA[<p><span align="left"><strong>1. 将请求参数进行url编码</strong></span><br><span align="left"><strong>2. 不需要编码使用&lt;&gt;将网址括起来</strong></span></p><p>本文不对plantUML的语法进行解释，<a href="https://blog.csdn.net/heqiangflytosky/article/details/77050849" target="_blank" rel="noopener">直接戳</a>。</p><h1 id="对url进行编码"><a href="#对url进行编码" class="headerlink" title="对url进行编码"></a>对url进行编码</h1><p>需要编码的字符如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">abstract class AbstractList;</span><br><span class="line">interface List;</span><br><span class="line">List &lt;|.. AbstractList;</span><br></pre></td></tr></table></figure></p><h2 id="使用在线编码网站提供的服务，直接戳"><a href="#使用在线编码网站提供的服务，直接戳" class="headerlink" title="使用在线编码网站提供的服务，直接戳"></a>使用在线编码网站提供的服务，<a href="https://meyerweb.com/eric/tools/dencoder/" target="_blank" rel="noopener">直接戳</a></h2><a id="more"></a><p>编码后的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abstract%20class%20AbstractList%3B%0Ainterface%20List%3B%0AList%20%3C%7C..%20AbstractList%3B</span><br></pre></td></tr></table></figure></p><p>请求的url为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://g.gravizo.com/svg?abstract%20class%20AbstractList%3B%0Ainterface%20List%3B%0AList%20%3C%7C..%20AbstractList%3B</span><br></pre></td></tr></table></figure></p><p>在markdown文件中使用：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">示例1</span>](<span class="link">http://g.gravizo.com/svg?abstract%20class%20AbstractList%3B%0Ainterface%20List%3B%0AList%20%3C%7C..%20AbstractList%3B</span>)</span><br></pre></td></tr></table></figure></p><p>结果如下：<br><img src="http://g.gravizo.com/svg?abstract%20class%20AbstractList%3B%0Ainterface%20List%3B%0AList%20%3C%7C..%20AbstractList%3B" alt="示例1"></p><h2 id="使用python的库urllib进行编码"><a href="#使用python的库urllib进行编码" class="headerlink" title="使用python的库urllib进行编码"></a>使用python的库urllib进行编码</h2><ol><li>打开终端</li><li><p>输入python,显示结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ python</span><br><span class="line">Python 2.7.10 (default, Jul 14 2015, 19:46:27)</span><br><span class="line">[GCC 4.2.1 Compatible Apple LLVM 6.0 (clang-600.0.39)] on darwin</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></li><li><p>引入urllib库:import urllib</p></li><li>为变量raw赋值：raw = ‘’’abstract class AbstractList;interface List;List &lt;|.. AbstractList;’’’</li><li>使用urllib的quote()方法:urllib.quote(raw)，将得到如下的结果:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import urllib</span><br><span class="line">&gt;&gt;&gt; raw = &apos;&apos;&apos;</span><br><span class="line">... abstract class AbstractList;</span><br><span class="line">... interface List;</span><br><span class="line">... List &lt;|.. AbstractList;</span><br><span class="line">... &apos;&apos;&apos;</span><br><span class="line">&gt;&gt;&gt; urllib.quote(raw)</span><br><span class="line">&apos;%0Aabstract%20class%20AbstractList%3B%0Ainterface%20List%3B%0AList%20%3C%7C..%20AbstractList%3B%0A&apos;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></li></ol><p>得到结果与gravizo的网址组合在一起，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://g.gravizo.com/svg?%0Aabstract%20class%20AbstractList%3B%0Ainterface%20List%3B%0AList%20%3C%7C..%20AbstractList%3B%0A</span><br></pre></td></tr></table></figure></p><p>在markdown文件中使用：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">示例2</span>](<span class="link">http://g.gravizo.com/svg?%0Aabstract%20class%20AbstractList%3B%0Ainterface%20List%3B%0AList%20%3C%7C..%20AbstractList%3B%0A</span>)</span><br></pre></td></tr></table></figure></p><p>结果如下：<br><img src="http://g.gravizo.com/svg?%0Aabstract%20class%20AbstractList%3B%0Ainterface%20List%3B%0AList%20%3C%7C..%20AbstractList%3B%0A" alt="示例2"></p><h1 id="不需要编码使用-lt-gt-将网址括起来"><a href="#不需要编码使用-lt-gt-将网址括起来" class="headerlink" title="不需要编码使用&lt;&gt;将网址括起来"></a>不需要编码使用&lt;&gt;将网址括起来</h1><p>沿用上面的字符如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">abstract class AbstractList;</span><br><span class="line">interface List;</span><br><span class="line">List &lt;|.. AbstractList;</span><br></pre></td></tr></table></figure></p><p>在markdown中使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![示例3](&lt;http://g.gravizo.com/g?abstract class AbstractList;interface List;List &lt;|.. AbstractList;&gt;)</span><br></pre></td></tr></table></figure></p><p><img src="http://g.gravizo.com/g?abstract class AbstractList;interface List;List &lt;|.. AbstractList;" alt="示例3"><br><strong>注意&lt;&gt;中的url连接不能有回车符号，但可以有空格</strong></p><h1 id="UML类图各线条怎么表示"><a href="#UML类图各线条怎么表示" class="headerlink" title="UML类图各线条怎么表示"></a><a href="http://plantuml.com/class-diagram" target="_blank" rel="noopener">UML类图各线条怎么表示</a></h1><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">child --|&gt; parent</span><br><span class="line">![<span class="string">继承</span>](<span class="link">http://g.gravizo.com/svg?Child --|&gt; Parent;</span>)</span><br><span class="line">or </span><br><span class="line">![<span class="string">继承</span>](<span class="link">http://g.gravizo.com/svg?Parent &lt;|-- Child;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://g.gravizo.com/svg?Child --|&gt; Parent;" alt="继承"><br>or<br><img src="http://g.gravizo.com/svg?Parent &lt;|-- Child;" alt="继承"></p><h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ServiceImpl ..|&gt; Service</span><br><span class="line">![<span class="string">实现接口</span>](<span class="link">http://g.gravizo.com/svg?ServiceImpl ..|&gt; interface Service;</span>)</span><br><span class="line">or</span><br><span class="line">![<span class="string">实现接口</span>](<span class="link">http://g.gravizo.com/svg?nterface Service &lt;|.. ServiceImpl;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://g.gravizo.com/svg?ServiceImpl ..|&gt; interface Service;" alt="实现接口"><br>or<br><img src="http://g.gravizo.com/svg?interface Service &lt;|.. ServiceImpl;" alt="实现接口"></p><h2 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class09 -- Class10</span><br><span class="line">![<span class="string">关联</span>](<span class="link">http://g.gravizo.com/svg?Class09 -- Class10</span>)</span><br></pre></td></tr></table></figure><p><img src="http://g.gravizo.com/svg?Class09 -- Class10" alt="关联"></p><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class13 --&gt; Class14</span><br><span class="line">![<span class="string">依赖</span>](<span class="link">http://g.gravizo.com/svg?Class13 --&gt; Class14</span>)</span><br></pre></td></tr></table></figure><p><img src="http://g.gravizo.com/svg?Class13 &lt;.. Class14" alt="依赖"></p><h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Person1 --* Hand1</span><br><span class="line">or</span><br><span class="line">Person --* Hand : 2 contains 1 &lt;</span><br><span class="line">eg: </span><br><span class="line">![组合](http://g.gravizo.com/svg?Person *-- Hand : 1 contains 2 &gt;;Person1 --* Hand1)</span><br><span class="line">or</span><br><span class="line">![<span class="string">组合</span>](<span class="link">http://g.gravizo.com/svg?Person --* Hand : 2 contains 1 &lt;;Person1 --* Hand1</span>)</span><br></pre></td></tr></table></figure><p><img src="http://g.gravizo.com/svg?Person *-- Hand : 1 contains 2 &gt;;Person1 --* Hand1" alt="组合"><br>or<br><img src="http://g.gravizo.com/svg?Person --* Hand : 2 contains 1 &lt;;Person1 --* Hand1" alt="组合"></p><h1 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Wheel : 1 have 4 &gt;</span><br><span class="line">or</span><br><span class="line">Car1 "1" o-- "4" Wheel1</span><br><span class="line">eg: </span><br><span class="line">![<span class="string">聚合</span>](<span class="link">http://g.gravizo.com/svg?Car o-- Wheel : 1 have 4 &gt;;Car o-- Wheel</span>)</span><br><span class="line">or</span><br><span class="line">![<span class="string">聚合</span>](<span class="link">http://g.gravizo.com/svg?Wheel1 --o Car1 : 4 have 1 &lt;;Wheel1 --o Car1</span>)</span><br></pre></td></tr></table></figure><p><img src="http://g.gravizo.com/svg?Car o-- Wheel : 1 have 4 &gt;;Car1 o-- Wheel1" alt="聚合"><br>or<br><img src="http://g.gravizo.com/svg?Wheel --o Car : 4 have 1 &lt;;Wheel1 --o Car1" alt="聚合"></p><blockquote><p>参考链接</p><footer><strong>Markdown 绘制 UML 图 -- PlantUML + Gravizo</strong><cite><a href="https://blog.csdn.net/heqiangflytosky/article/details/77050849" target="_blank" rel="noopener">blog.csdn.net/heqiangflytosky/article/details/77050849</a></cite></footer></blockquote><blockquote><footer><strong>Markdown 绘制 UML 图 -- PlantUML + Gravizo</strong><cite><a href="https://www.heqiangfly.com/2017/07/08/development-tool-markdown-plant-uml/" target="_blank" rel="noopener">www.heqiangfly.com/2017/07/08/development-tool-markdown-plant-uml</a></cite></footer></blockquote><blockquote><footer><strong>URL Decoder/Encoder</strong><cite><a href="https://meyerweb.com/eric/tools/dencoder/" target="_blank" rel="noopener">meyerweb.com/eric/tools/dencoder</a></cite></footer></blockquote><blockquote><footer><strong>plantUML online editor</strong><cite><a href="http://www.plantuml.com/plantuml/uml/SoWkIImgAStDuGh9BCb9LL1wldlviyxzJritFz-y--diVKfSReab6Qb52ZOrkheAmVbvN0wfUIb0zG00" target="_blank" rel="noopener">www.plantuml.com/plantuml/uml/SoWkIImgAStDuGh9BCb9LL1wldlviyxzJritFz-y--diVKfSReab6Qb52ZOrkheAmVbvN0wfUIb0zG00</a></cite></footer></blockquote><p><a href="https://www.ibm.com/support/knowledgecenter/zh/SS4JE2_7.5.5/com.ibm.xtools.modeler.doc/topics/cassn.html?pos=2" target="_blank" rel="noopener">https://www.ibm.com/support/knowledgecenter/zh/SS4JE2_7.5.5/com.ibm.xtools.modeler.doc/topics/cassn.html?pos=2</a></p>]]></content>
      
      <categories>
          
          <category> Markdown </category>
          
          <category> 画图 </category>
          
          <category> UML类图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UML </tag>
            
            <tag> 类图 </tag>
            
            <tag> Markdown </tag>
            
            <tag> plantUML </tag>
            
            <tag> gravizo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LinkedList</title>
      <link href="/2018/04/28/LinkedList/"/>
      <url>/2018/04/28/LinkedList/</url>
      <content type="html"><![CDATA[<p><span align="left"><strong>1. java中LinkedList是单链表实现还是双链表实现？</strong></span><br><span align="left"><strong>2. java中LinkedList节点元素的结构是怎样的？</strong></span><br><span align="left"><strong>3. java中LinkedList的get（int index）方法是如何实现的？以及add（）方法是如何实现的？</strong></span></p><a id="more"></a><h1 id="java中LinkedList是单链表实现还是双链表实现？"><a href="#java中LinkedList是单链表实现还是双链表实现？" class="headerlink" title="java中LinkedList是单链表实现还是双链表实现？"></a>java中LinkedList是单链表实现还是双链表实现？</h1><h1 id="java中LinkedList节点元素的结构是怎样的？"><a href="#java中LinkedList节点元素的结构是怎样的？" class="headerlink" title="java中LinkedList节点元素的结构是怎样的？"></a>java中LinkedList节点元素的结构是怎样的？</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上diamante截取自jdk8的LinkedList类，它是LinkedList类中节点元素，可以看出java中LinkedList是双链表实现的，因为静态内部类Node有两个指针，一个指向父节点，一个指向子节点（问题1，2自解）</p><h1 id="java中LinkedList的get（int-index）方法是如何实现的？以及add（）方法是如何实现的？"><a href="#java中LinkedList的get（int-index）方法是如何实现的？以及add（）方法是如何实现的？" class="headerlink" title="java中LinkedList的get（int index）方法是如何实现的？以及add（）方法是如何实现的？"></a>java中LinkedList的get（int index）方法是如何实现的？以及add（）方法是如何实现的？</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == size)</span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert succ != null;</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pred.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面这段代码可以看出，当调用LinkedList的add(E)方法插入元素时，默认插入链表的末尾；当调用LinkedList的add(int, E)方法在指定位置插入元素时，通过node(int index)方法遍历链表，找到该索引位置的元素节点（在查找时用到了折半的思想，当索引小于size的一半时从前向后遍历，否则从后向前遍历），然后做节点的插入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面这段代码可以看出，java中LinkedList的get(int index)方法查询元素时，会通过node(int index)方法遍历链表找到对应位置的元素节点（上一段代码有给出node方法的源码），并返回其值</p><p>Java中LinkedList的UML类图</p><p><img src="http://g.gravizo.com/svg?interface Deque;interface Queue;abstract class AbstractList;abstract class AbstractSequentialList;abstract class AbstractCollection;interface Collection;interface List;Collection &lt;|-- List;Collection &lt;|.. AbstractCollection;AbstractCollection &lt;|-- AbstractList;AbstractList &lt;|-- AbstractSequentialList;AbstractSequentialList &lt;|-- LinkedList;List &lt;|.. LinkedList;Collection &lt;|-- Queue;Queue &lt;|-- Deque;Deque &lt;|.. LinkedList;List &lt;|.. AbstractList;" alt="LinkedList类图"></p>]]></content>
      
      <categories>
          
          <category> JDK </category>
          
          <category> Collections </category>
          
          <category> List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JDK </tag>
            
            <tag> List </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>macOS系统使用hexo创建文章时自动用喜爱的编辑器打开</title>
      <link href="/2018/04/26/macOS%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8hexo%E5%88%9B%E5%BB%BA%E6%96%87%E7%AB%A0%E6%97%B6%E8%87%AA%E5%8A%A8%E7%94%A8%E5%96%9C%E7%88%B1%E7%9A%84%E7%BC%96%E8%BE%91%E5%99%A8%E6%89%93%E5%BC%80/"/>
      <url>/2018/04/26/macOS%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8hexo%E5%88%9B%E5%BB%BA%E6%96%87%E7%AB%A0%E6%97%B6%E8%87%AA%E5%8A%A8%E7%94%A8%E5%96%9C%E7%88%B1%E7%9A%84%E7%BC%96%E8%BE%91%E5%99%A8%E6%89%93%E5%BC%80/</url>
      <content type="html"><![CDATA[<p>在博客根目录下找到scripts文件夹，如果没有就创建该文件夹，在scripts文件夹中创建open.js,内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var spawn = require(&apos;child_process&apos;).spawn;</span><br><span class="line"></span><br><span class="line">hexo.on(&apos;new&apos;, function(data)&#123;</span><br><span class="line">  spawn(&apos;open&apos;, [&apos;-a&apos;, &apos;/Applications/Visual\ Studio\ Code.app&apos;, data.path]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>当我们在博客根目录下使用终端新建文件时会使用VScode编辑器打开该文章，可以方便地进行编辑<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new article_name</span><br></pre></td></tr></table></figure></p><blockquote><p>参考链接</p><footer><strong>hexo new 后同步打开文章编辑器</strong><cite><a href="https://www.jianshu.com/p/4487d767e651" target="_blank" rel="noopener">www.jianshu.com/p/4487d767e651</a></cite></footer></blockquote><blockquote><footer><strong>Nodejs进阶：如何玩转子进程（child_process）</strong><cite><a href="http://www.cnblogs.com/chyingp/p/node-learning-guide-child_process.html" target="_blank" rel="noopener">www.cnblogs.com/chyingp/p/node-learning-guide-child_process.html</a></cite></footer></blockquote>]]></content>
      
      
        <tags>
            
            <tag> Mac </tag>
            
            <tag> Hexo </tag>
            
            <tag> VScode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hashMap</title>
      <link href="/2018/04/26/hashMap/"/>
      <url>/2018/04/26/hashMap/</url>
      <content type="html"><![CDATA[<h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p>关于HashMap的几个基本问题：</p><ol><li>hashMap的工作原理？</li><li>hashMap可以接收key为null的键值对吗？hashTable可以接收key为null的键值对吗？</li><li>hashMap的负载因子是做什么的？</li><li>hashMap在JDK7和JDK8中的区别是什么？</li><li>简述HashMap的put方法的过程</li><li>简述HashMap的get方法的过程</li><li>什么时候会使用HashMap？他有什么特点？</li><li>你知道HashMap的工作原理吗？</li><li>你知道get和put的原理吗？equals()和hashCode()的都有什么作用？</li><li>你知道hash的实现吗？为什么要这样实现？</li><li>如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？</li></ol><a id="more"></a><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><ul><li>什么时候会使用HashMap？他有什么特点？<br>需要保存key-value形式的键值对时，需要要使用HashMap，或者我们希望通过key快速查询到它所对应的value时，就会使用HashMap<br>HashMap的特点：将key散列到表中，使用key的散列值查询元素，理想情况下，查询元素的时间复杂度是常数级别；通常情况下，保存key、value时，如果需要保存的key已经存在于散列表中，后面的值会覆盖前面的值；HashMap的键和值都允许是null，HashMap保存元素的最大值是Integer.MAX_VALUE；</li></ul><h1 id="在JDK7和JDK8中最大的区别就是"><a href="#在JDK7和JDK8中最大的区别就是" class="headerlink" title="在JDK7和JDK8中最大的区别就是"></a>在JDK7和JDK8中最大的区别就是</h1><p>JDK8优化了当发生严重hash冲突时的查询优化，当满足一定的条件，使用红黑树代替链表来存储数据</p><h1 id="HashMap的工作原理"><a href="#HashMap的工作原理" class="headerlink" title="HashMap的工作原理"></a>HashMap的工作原理</h1><p>HashMap的工作原理就是通过计算key的hash值，将key、value保存到对应的hash桶中，如果发生hash冲突，就用链表的方式将这些key、value连接起来；<br>访问某个key、value时，同样的方式，先计算key的hash值，从而定位key、value所在的hash桶</p><h1 id="put方法的过程"><a href="#put方法的过程" class="headerlink" title="put方法的过程"></a>put方法的过程</h1><ol><li>判断数据是否为空，为空就resize，resize方法中包含了HashMap的初始化代码</li><li>通过hash方法计算key的hash值，确定桶的位置，如果索引位置的桶内元素为空，就将数据保存到该位置</li><li>如果桶内已经有元素了，判断该元素的key的hash是否与被插入的key的hash是否相等，以及key是否相等，如果相等，则替换值</li><li>如果不相等，再判断该节点是否是红黑树的节点，如果是，则调用添加树节点的方法插入数据</li><li>如果不是红黑树节点，则循环遍历链表，找到与key相等的节点就覆盖它的值，反之，则新增一个节点，链在链表的后面</li><li>在判断链表长度是否超过TREEFIY_THRESHOLD的值，如果超过了，就将链表树形化，</li><li>最后判断HashMap的容量是否超过了threshold, 如果超过了，就扩容</li></ol><h1 id="get方法的过程"><a href="#get方法的过程" class="headerlink" title="get方法的过程"></a>get方法的过程</h1><ol><li>如果HashMap中的table为空，或者key经过hash方法计算后的hash值所映射的桶为空，就返回空</li><li>反之，则判断桶里的元素的key的hash值、key值是否相等，如果相等，直接返回该元素</li><li>如果不相等，则判断该元素的下一个节点是否为空，如果为空，则返回空，如果不为空</li><li>则判断桶中的元素是否是TreeNode，如果是，则调用获取树节点的方法返回数据</li><li>反之，则遍历链表</li></ol><h2 id="hashMap的定义"><a href="#hashMap的定义" class="headerlink" title="hashMap的定义"></a>hashMap的定义</h2><p>hashMap是一种散列表，根据key的hash值被散列到表的不同位置，如果发生hash冲突，冲突的元素会以链表的形式存储</p><h2 id="put-K-k-V-v"><a href="#put-K-k-V-v" class="headerlink" title="put(K k, V v)"></a>put(K k, V v)</h2><p>查看put方法的源码，可以看出，hashMap是允许key为null的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>查看hash方法的源码，我们知道如果key为null，那么hash值是0，否则会调用key的hashCode方法计算key的hash值（这也是为什么要重写key的hashCode方法的原因），并将hash值与它的高16位进行异或操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当调用hashMap的put方法保存键值对时，通过hash方法重新计算key的hash值，如果hash值散列到散列表的索引处没有没有发生hash冲突，则将键值对保存即可,下面是putVal方法的代码片段<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">    tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure></p><p>如果发生hash冲突，判断hash值所对应的散列表位置的元素是不是TreeNode（jdk版本1.8），如果是，直接调用添加一个TreeNode节点，源码片段如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">    e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br></pre></td></tr></table></figure></p><p>如果fa’shegn不是TreeNode，</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>Java中HashMap的UML类图</p><p><img src="http://g.gravizo.com/svg?interface Map; abstract class AbstractMap;Map &lt;|.. AbstractMap;AbstractMap &lt;|-- HashMap;Map &lt;|.. HashMap;" alt="HashMap类图"></p>]]></content>
      
      <categories>
          
          <category> JDK </category>
          
          <category> Collections </category>
          
          <category> Map </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JDK </tag>
            
            <tag> Map </tag>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2017/08/27/hello-world/"/>
      <url>/2017/08/27/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><p>blog框架<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">hexo</a>,主题框架<a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">NexT</a></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><a id="more"></a><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><h2 id="标签插件（Tags-Plugins"><a href="#标签插件（Tags-Plugins" class="headerlink" title="标签插件（Tags Plugins)"></a>标签插件（Tags Plugins)</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% blockquote [author[, source]] [link] [source<span class="emphasis">_link_</span>title] %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endblockquote %&#125;</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://hexo.io/zh-cn/docs/tag-plugins.html" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/tag-plugins.html</a></p>]]></content>
      
      
    </entry>
    
  
  
</search>
